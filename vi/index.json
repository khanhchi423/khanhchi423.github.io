[
{
	"uri": "/vi/2-prerequiste/2.1-install-nodejs/",
	"title": "Cài đặt Node.js &amp; npm",
	"tags": [],
	"description": "",
	"content": "Tải Node.js \u0026amp; npm Truy cập trang chủ Node.js và chọn phiên bản LTS để tải về, tương thích với hệ điều hành của bạn (Windows, macOS, Linux).\nChạy tệp cài đặt vừa tải và làm theo hướng dẫn để cài đặt Node.js.\nSau khi cài đặt hoàn tất, mở Terminal và kiểm tra phiên bản Node.js và npm bằng lệnh sau:\nnode -v npm -v Nếu xuất hiện kết quả như hình dưới đây, điều đó có nghĩa là bạn đã cài đặt thành công.\n"
},
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "🎯 Mô hình Event Sourcing là một mô hình kiến trúc trong thiết kế hệ thống phân tán, lưu trữ tất cả các thay đổi trạng thái ứng dụng dưới dạng chuỗi các sự kiện bất biến (immutable events), thay vì chỉ lưu trạng thái hiện tại. Cách tiếp cận này cung cấp khả năng theo dõi và kiểm tra toàn bộ lịch sử thay đổi mà không cần cập nhật hay xóa dữ liệu truyền thống trong cơ sở dữ liệu. Event Sourcing giúp dễ dàng tuân thủ các yêu cầu quy định pháp lý đòi hỏi lịch sử kiểm toán đầy đủ, quản lý dữ liệu nghiêm ngặt, và các hoạt động nghiệp vụ hoàn toàn có thể truy vết qua các bản ghi sự kiện chi tiết, đồng thời cung cấp cho nhà phát triển khả năng tái tạo trạng thái hiện tại và xử lý sự kiện theo thời gian thực trong các ứng dụng hiện đại.\nNguyên tắc cốt lõi:\nSự kiện bất biến: Mỗi thay đổi được ghi nhận dưới dạng sự kiện không thể thay đổi Lưu trữ chỉ thêm mới: Các sự kiện chỉ được thêm vào, không được cập nhật hay xóa Tái tạo trạng thái: Trạng thái hiện tại được tính toán lại bằng cách phát lại các sự kiện Lịch sử đầy đủ: Lưu giữ toàn bộ lịch sử thay đổi của hệ thống Cách tiếp cận này đảm bảo tính minh bạch, truy xuất lịch sử và tuân thủ các quy định pháp lý yêu cầu có lịch sử kiểm toán chi tiết, đồng thời cung cấp khả năng tái tạo trạng thái linh hoạt và xử lý sự kiện theo thời gian thực cho các ứng dụng hiện đại.\n🔀 CQRS (Phân tách trách nhiệm lệnh và truy vấn) Event Sourcing thường được kết hợp với mô hình CQRS để tối ưu hiệu suất:\nCQRS là gì?\nLệnh (Command): Xử lý các thao tác ghi (Tạo, Cập nhật, Xóa) Truy vấn (Query): Xử lý các thao tác đọc (Đọc dữ liệu) Phân tách trách nhiệm: Tách biệt rõ ràng các trách nhiệm ghi và đọc Lợi ích khi kết hợp CQRS với Event Sourcing:\nTối ưu độc lập cho đọc và ghi: Mô hình đọc và ghi có thể được tối ưu riêng biệt Khả năng mở rộng: Có thể mở rộng riêng rẽ cho các thao tác đọc và ghi Linh hoạt: Có thể xây dựng nhiều mô hình đọc khác nhau từ cùng một kho sự kiện Hiệu năng: Các truy vấn được tối ưu riêng cho từng trường hợp sử dụng So sánh Event Sourcing và CRUD Khía cạnh CRUD Event Sourcing Lưu trữ dữ liệu Lưu trạng thái hiện tại Lưu chuỗi các sự kiện Mất dữ liệu Mất lịch sử khi cập nhật Giữ nguyên lịch sử đầy đủ Lịch sử kiểm toán Cần cài đặt riêng Tự động có sẵn Độ phức tạp Đơn giản Phức tạp hơn Hiệu suất đọc Nhanh với các truy vấn đơn giản Rất tối ưu với các mô hình đọc Hiệu suất ghi Có thể trở thành nút thắt cổ chai Ghi chỉ thêm mới, nhanh hơn Khả năng mở rộng Hạn chế Cao, có thể mở rộng độc lập Gỡ lỗi Khó khăn để truy vết lịch sử Dễ dàng gỡ lỗi và phát lại sự kiện Tính nhất quán Giao dịch ACID Nhất quán theo thời gian (Eventual Consistency) Kiến trúc tổng thể của hệ thống chúng ta sẽ xây dựng: ☁️ Mô tả các thành phần kiến trúc 🔄 Luồng chính:\nYêu cầu từ Client\nClient gửi yêu cầu qua CloudFront (mạng phân phối nội dung toàn cầu - CDN) CloudFront cache nội dung tĩnh và điều hướng các yêu cầu động API Gateway\nNhận yêu cầu từ CloudFront Xử lý xác thực, giới hạn tần suất, kiểm tra hợp lệ yêu cầu Định tuyến yêu cầu đến các hàm Lambda phù hợp Command Handler (Lambda)\nXử lý nghiệp vụ cho các thao tác ghi Xác thực lệnh và tạo ra các sự kiện Thêm các sự kiện vào EventStore (DynamoDB) Event Processing Pipeline\nEventBridge: Điều phối và lọc sự kiện qua quy tắc \u0026ldquo;OrderEventBus\u0026rdquo; CloudWatch + X-Ray: Giám sát và truy vết phân tán Định tuyến sự kiện đến các bộ xử lý thích hợp Lưu trữ \u0026amp; phát lại sự kiện\nEventStore (DynamoDB): Lưu trữ các sự kiện bất biến Replay Lambda: Phát lại sự kiện khi cần tái tạo trạng thái ReadModel (DynamoDB): Các view được tạo vật chất tối ưu cho truy vấn Xử lý truy vấn\nQuery Lambda: Xử lý các thao tác đọc từ ReadModel SNS: Thông báo và phát hành sự kiện 🔧 Các công nghệ Serverless sử dụng Dịch vụ Vai trò AWS Lambda Xử lý Command/Query EventBridge Bus sự kiện và định tuyến DynamoDB Lưu trữ sự kiện và mô hình đọc API Gateway Endpoint REST API S3 + CloudFront Lưu trữ website tĩnh CloudWatch Giám sát và ghi log X-Ray Truy vết phân tán SNS Pub/Sub nhắn tin 🚀 Kết thúc workshop thực hành này, bạn sẽ có kinh nghiệm xây dựng hệ thống chịu lỗi, tuân thủ kiểm toán sử dụng mô hình Event Sourcing và CQRS, cũng như tự tin thiết kế các ứng dụng serverless phức tạp với luồng nghiệp vụ có khả năng truy xuất lịch sử đầy đủ.\n"
},
{
	"uri": "/vi/8-testing/8.1-testing/",
	"title": "Kiểm thử ứng dụng",
	"tags": [],
	"description": "",
	"content": "Bước 1: Truy cập ứng dụng Mở trình duyệt web và truy cập vào URL trang web tĩnh S3 của bạn. Bạn sẽ thấy trang chủ ứng dụng FAST FOOD. Nhấp vào Place order để bắt đầu kiểm thử chức năng đặt hàng. Bước 2: Đặt một đơn hàng thử nghiệm Ở phần menu, chọn một món (ví dụ: Coca Cola).\nNhấp nút + để thêm vào giỏ hàng.\nĐiền thông tin khách hàng:\nTên: ho chi khanh Số điện thoại: 0937026887 Địa chỉ: quận 9 Nhấp Checkout để đặt đơn hàng. Bước 3: Xác nhận trạng thái đơn hàng Sau khi đặt đơn, bạn sẽ thấy trạng thái đơn thay đổi thành Confirmed. Ghi lại mã đơn hàng (ví dụ: Order #23b07487\u0026hellip;) và thời gian đặt. Đơn hàng sẽ hiển thị trạng thái \u0026ldquo;Order confirmed and being prepared\u0026rdquo; (Đơn hàng đã được xác nhận và đang được chuẩn bị). Bước 4: Kiểm tra email thông báo Kiểm tra hộp thư email đã đăng ký nhận thông báo SNS.\nBạn sẽ nhận được email với tiêu đề: [ADMIN] New Order Placed - #23b07487\nEmail sẽ chứa thông tin:\nMã đơn hàng: 23b07487-9bc8-47b3-a013-86238ec216fd Khách hàng: ho chi khanh Số điện thoại: 0937026887 Tổng tiền: $2.99 Trạng thái: PLACED Bước 5: Kiểm thử xác nhận đơn hàng Trên trang chi tiết đơn hàng, bạn sẽ thấy trạng thái đơn là Pending. Bạn sẽ thấy thông báo \u0026ldquo;Order is awaiting your action\u0026rdquo; (Đơn hàng đang chờ bạn xử lý). Nhấp nút Confirm Order để xác nhận đơn. Lưu ý còn có tùy chọn Cancel Order để hủy đơn. Bước 6: Kiểm thử quản lý đơn hàng Bạn có thể kiểm thử chức năng quản lý đơn bằng cách:\nNhấp Cancel Order để hủy đơn. Nhấp Confirm Order để xác nhận đã nhận đơn. Mỗi thao tác sẽ kích hoạt cập nhật trạng thái và gửi thông báo tương ứng.\nBước 7: Kiểm tra dữ liệu trong cơ sở dữ liệu Truy cập AWS Console và vào DynamoDB. Nhấp Explore items để xem dữ liệu đã lưu. Kiểm tra bảng EventStore Kiểm tra bảng OrderReadModel Kiểm tra bảng CustomerReadModel "
},
{
	"uri": "/vi/3-eventstore/3.1-create-eventstore-table/",
	"title": "Tạo bảng EventStore",
	"tags": [],
	"description": "",
	"content": "Bước 1: Mở DynamoDB Console Trong AWS Management Console, tìm kiếm DynamoDB. Nhấn DynamoDB để mở dịch vụ. Bước 2: Tạo bảng Nhấn Create table.\nNhập Table name: EventStore Nhập Partition key: aggregateId (String) Nhập Sort key: eventId (String) Chọn Default settings. Nhấn Create table.\n✅ Kết quả: Bảng EventStore sẽ được tạo với aggregateId và eventId làm khóa.\nBước 3: Tạo Global Secondary Index Sau khi bảng EventStore được tạo, bạn cần thêm Global Secondary Index để truy vấn hiệu quả hơn.\nTrong bảng EventStore, mở tab Indexes.\nNhấn nút Create index.\nCấu hình Global Secondary Index:\nPartition key: aggregateId (String) Sort key: timestamp (String) Index name: AggregateIndex Data type: Giữ cả hai là String Capacity mode: On-demand (mặc định) Giữ nguyên các thiết lập khác và nhấn Create index. ✅ Kết quả: Bảng EventStore hiện đã sẵn sàng với:\nPrimary key: aggregateId (Partition) + eventId (Sort) Global Secondary Index: AggregateIndex với aggregateId (Partition) + timestamp (Sort) On-demand capacity mode để tự động mở rộng. Cấu hình này cho phép truy vấn sự kiện một cách hiệu quả cả theo eventId riêng lẻ và theo aggregate với thứ tự thời gian.\n"
},
{
	"uri": "/vi/6-configapigateway/6.1-create-new-api-gateway/",
	"title": "Tạo mới API Gateway",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo một REST API mới bằng Amazon API Gateway để đóng vai trò là giao diện HTTP cho hệ thống đặt đồ ăn nhanh. API này sẽ cung cấp các endpoint để quản lý đơn hàng và tích hợp với các hàm Lambda triển khai kiến trúc Event Sourcing.\nBước 1: Mở Amazon API Gateway Console Trong AWS Management Console, tìm kiếm API Gateway. Nhấp vào API Gateway để mở dịch vụ. Bước 2: Tạo REST API mới Nhấp nút Create API.\nChọn REST API và nhấn Build.\nCấu hình API:\nChọn giao thức: REST Tạo API mới: New API (được chọn mặc định) Tên API: FastFoodOrderAPI Mô tả: API cho Hệ thống Đặt Đồ ăn Nhanh Loại endpoint API: Regional Nhấn Create API.\n✅ Kết quả: REST API FastFoodOrderAPI đã được tạo thành công và sẵn sàng để cấu hình resource và method.\nBước 3: Tạo Resource /orders Trong API vừa tạo → Chọn Create Resource\nCấu hình resource:\nTên Resource: orders Đường dẫn Resource: /orders Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource\nBước 4: Tạo method POST cho /orders Chọn resource /orders Nhấn Actions → Create Method\nChọn POST từ danh sách thả xuống → Nhấn ✓ Cấu hình method: Loại tích hợp (Integration type): Lambda Function Vùng Lambda (Lambda Region): Chọn vùng của bạn Hàm Lambda (Lambda Function): OrderCommandHandler Sử dụng thời gian chờ mặc định (Use Default Timeout): Chọn tùy chọn này Nhấn Save Nhấn OK để cho phép API Gateway gọi Lambda\nBước 5: Tạo method GET cho /orders Chọn resource /orders Nhấn Actions → Create Method Chọn GET → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): OrderQueryHandler Nhấn Save → OK Bước 6: Tạo Resource /orders/{id} Chọn resource /orders Nhấn Actions → Create Resource Cấu hình: Tên Resource: {id} Đường dẫn Resource: /{id} Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 7: Tạo method GET cho /orders/{id} Chọn resource /{id} Nhấn Actions → Create Method Chọn GET → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): OrderQueryHandler Nhấn Save → OK Bước 8: Tạo Resource /orders/confirm Chọn resource /orders Nhấn Actions → Create Resource Cấu hình: Tên Resource: confirm Đường dẫn Resource: /confirm Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 9: Tạo method POST cho /orders/confirm Chọn resource /confirm Nhấn Actions → Create Method Chọn POST → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): OrderCommandHandler Nhấn Save → OK Bước 10: Tạo Resource /orders/cancel Chọn resource /orders Nhấn Actions → Create Resource Cấu hình: Tên Resource: cancel Đường dẫn Resource: /cancel Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 11: Tạo method POST cho /orders/cancel Chọn resource /cancel Nhấn Actions → Create Method Chọn POST → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): OrderCommandHandler Nhấn Save → OK Bước 12: Tạo Resource /menu Chọn resource gốc / Nhấn Actions → Create Resource Cấu hình: Tên Resource: menu Đường dẫn Resource: /menu Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 13: Tạo method GET cho /menu Chọn resource /menu Nhấn Actions → Create Method Chọn GET → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): OrderQueryHandler Nhấn Save → OK Bước 14: Tạo Resource /customers Chọn resource gốc / Nhấn Actions → Create Resource Cấu hình: Tên Resource: customers Đường dẫn Resource: /customers Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 15: Tạo method GET cho /customers Chọn resource /customers Nhấn Actions → Create Method Chọn GET → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): OrderQueryHandler Nhấn Save → OK Bước 16: Tạo Resource /reconstruct Chọn resource gốc / Nhấn Actions → Create Resource Cấu hình: Tên Resource: reconstruct Đường dẫn Resource: /reconstruct Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 17: Tạo Resource /reconstruct/order Chọn resource /reconstruct Nhấn Actions → Create Resource Cấu hình: Tên Resource: order Đường dẫn Resource: /order Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 18: Tạo method POST cho /reconstruct/order Chọn resource /reconstruct/order Nhấn Actions → Create Method Chọn POST → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): StateReconstructionHandler Nhấn Save → OK Bước 19: Tạo Resource /reconstruct/all Chọn resource /reconstruct Nhấn Actions → Create Resource Cấu hình: Tên Resource: all Đường dẫn Resource: /all Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource Bước 20: Tạo method POST cho /reconstruct/all Chọn resource /reconstruct/all Nhấn Actions → Create Method Chọn POST → Nhấn ✓ Cấu hình: Loại tích hợp (Integration type): Lambda Function Hàm Lambda (Lambda Function): StateReconstructionHandler Nhấn Save → OK Bước 21: Tạo Resource /reconstruct/validate Chọn resource /reconstruct Nhấn Actions → Create Resource Cấu hình: Tên Resource: validate Đường dẫn Resource: /validate Bật API Gateway CORS: Chọn tùy chọn này Nhấn Create Resource "
},
{
	"uri": "/vi/7-deployfrontend/7.1-create-s3-bucket/",
	"title": "Tạo S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Bước 1: Truy cập S3 Console Trong AWS Management Console, tìm kiếm S3. Nhấp vào S3 để mở dịch vụ. Bước 2: Tạo Bucket Mới Nhấp Create bucket. Nhập tên bucket duy nhất, ví dụ:\nevent-sourcing-fastfood-frontend Chọn region gần người dùng của bạn nhất (ví dụ: ap-southeast-1). Trong Block Public Access settings for this bucket, bỏ chọn tất cả các ô để cho phép truy cập công khai khi host website tĩnh. Nhấp Create bucket. Mở bucket vừa tạo. Chuyển sang tab Properties. Kéo xuống mục Static website hosting và nhấp Edit. Chọn Enable. Đặt Index document thành index.html. Nhấp Save changes. Bước 3: Cấu hình Bucket Policy cho Truy cập Công khai Vẫn trong bucket của bạn, vào tab Permissions. Kéo xuống Bucket policy và nhấp Edit. Thêm bucket policy sau để cho phép đọc công khai các file website tĩnh: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::event-sourcing-fastfood-frontend/*\u0026#34; } ] } Thay thế event-sourcing-fastfood-frontend bằng tên bucket thực tế của bạn.\nNhấp Save changes để lưu thay đổi.\n"
},
{
	"uri": "/vi/5-setupeventbridge/5.1-customeventbus/",
	"title": "Thiết lập Custom Event Bus cho Quy trình Event Sourcing",
	"tags": [],
	"description": "",
	"content": "Bước 1: Mở Amazon EventBridge Console Trong AWS Management Console, tìm kiếm EventBridge. Nhấn Amazon EventBridge để mở dịch vụ. Bước 2: Tạo Event Bus Ở bảng điều hướng bên trái, chọn Event buses. Nhấn Create event bus. Name: Nhập FastFoodOrderBus Description: Nhập Custom event bus for fastfood order events Giữ nguyên thiết lập mặc định cho Encryption. Nhấn Create event bus. ✅ Kết quả: Event bus tùy chỉnh FastFoodOrderBus đã được tạo thành công và sẵn sàng nhận các sự kiện đơn hàng.\n"
},
{
	"uri": "/vi/",
	"title": "TRIỂN KHAI HỆ THỐNG ĐẶT HÀNG SERVERLESS VỚI EVENT SOURCING TRÊN AWS",
	"tags": [],
	"description": "",
	"content": "TRIỂN KHAI HỆ THỐNG ĐẶT HÀNG SERVERLESS VỚI EVENT SOURCING TRÊN AWS Tổng quan Trong workshop này, bạn sẽ học các kiến thức nền tảng và cách triển khai thực tế của Mô hình Event Sourcing bằng các dịch vụ Serverless của AWS. Bạn sẽ xây dựng một hệ thống đặt đồ ăn nhanh hoàn chỉnh với khả năng xử lý sự kiện tức thì, tái tạo trạng thái và giám sát toàn diện.\nKiến trúc tổng quan của hệ thống chúng ta sẽ xây dựng: Nội dung Giới thiệu Các bước chuẩn bị Tạo Event Store (DynamoDB) Thiết lập EventBridge Pipeline Triển khai các hàm Lambda Cấu hình API Gateway Triển khai ứng dụng Frontend Kiểm thử \u0026amp; Giám sát Dọn dẹp tài nguyên "
},
{
	"uri": "/vi/4-deploylambda/4.1-implementfunctionordercommandhandler/",
	"title": "Triển khai OrderCommandHandler ",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ triển khai hàm Lambda OrderCommandHandler để xử lý các lệnh (command) liên quan đến đơn hàng trong hệ thống đặt đồ ăn nhanh.\nHàm này sẽ thực hiện các tác vụ như đặt hàng, xác nhận đơn hàng và hủy đơn hàng.\nBước 1: Mở Lambda Console Trong AWS Management Console, tìm kiếm Lambda. Nhấn vào Lambda để mở dịch vụ.\nBước 2: Tạo hàm Lambda Nhấn Create function.\nChọn Author from scratch.\nNhập Function name: OrderCommandHandler.\nChọn Runtime: Python 3.12.\nChọn Architecture: x86_64.\nMở rộng mục Change default execution role.\nChọn Use an existing role.\nChọn EventSourcingLambdaRole từ danh sách.\nNhấn Create function.\nBước 3: Triển khai mã hàm Trong phần Code source của hàm OrderCommandHandler, thay thế mã mặc định bằng đoạn sau: import json import boto3 import uuid from datetime import datetime, timedelta from decimal import Decimal # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) eventbridge = boto3.client(\u0026#39;events\u0026#39;) # DynamoDB tables event_store_table = dynamodb.Table(\u0026#39;EventStore\u0026#39;) menu_items_table = dynamodb.Table(\u0026#39;MenuItems\u0026#39;) def lambda_handler(event, context): try: # Parse request http_method = event[\u0026#39;httpMethod\u0026#39;] path = event[\u0026#39;path\u0026#39;] body = json.loads(event[\u0026#39;body\u0026#39;]) if event.get(\u0026#39;body\u0026#39;) else {} print(f\u0026#34;Processing {http_method} {path}\u0026#34;) print(f\u0026#34;Body: {body}\u0026#34;) if path == \u0026#39;/orders\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_place_order(body) elif path == \u0026#39;/orders/confirm\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_confirm_order(body) elif path == \u0026#39;/orders/cancel\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_cancel_order(body) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Endpoint not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;}) def handle_place_order(order_data): # Validate order data required_fields = [\u0026#39;customerName\u0026#39;, \u0026#39;customerPhone\u0026#39;, \u0026#39;customerAddress\u0026#39;, \u0026#39;items\u0026#39;] if not all(field in order_data for field in required_fields): return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Missing required fields\u0026#39;}) # Validate items if not order_data[\u0026#39;items\u0026#39;] or len(order_data[\u0026#39;items\u0026#39;]) == 0: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Order must contain at least one item\u0026#39;}) # Generate order ID order_id = str(uuid.uuid4()) # Calculate total amount total_amount = Decimal(\u0026#39;0\u0026#39;) validated_items = [] for item in order_data[\u0026#39;items\u0026#39;]: if \u0026#39;itemId\u0026#39; not in item or \u0026#39;quantity\u0026#39; not in item: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Each item must have itemId and quantity\u0026#39;}) # Get item price from menu try: menu_item = menu_items_table.get_item(Key={\u0026#39;itemId\u0026#39;: item[\u0026#39;itemId\u0026#39;]}) if \u0026#39;Item\u0026#39; not in menu_item: return build_response(400, {\u0026#39;error\u0026#39;: f\u0026#39;Item {item[\u0026#34;itemId\u0026#34;]} not found\u0026#39;}) menu_item_data = menu_item[\u0026#39;Item\u0026#39;] if not menu_item_data.get(\u0026#39;available\u0026#39;, False): return build_response(400, {\u0026#39;error\u0026#39;: f\u0026#39;Item {item[\u0026#34;itemId\u0026#34;]} is not available\u0026#39;}) item_price = Decimal(str(menu_item_data[\u0026#39;price\u0026#39;])) quantity = int(item[\u0026#39;quantity\u0026#39;]) item_total = item_price * quantity total_amount += item_total validated_items.append({ \u0026#39;itemId\u0026#39;: item[\u0026#39;itemId\u0026#39;], \u0026#39;name\u0026#39;: menu_item_data[\u0026#39;name\u0026#39;], \u0026#39;price\u0026#39;: item_price, # Keep as Decimal for DynamoDB \u0026#39;quantity\u0026#39;: quantity, \u0026#39;image\u0026#39;: menu_item_data.get(\u0026#39;image\u0026#39;, \u0026#39;\u0026#39;), \u0026#39;total\u0026#39;: item_total # Keep as Decimal for DynamoDB }) except Exception as e: print(f\u0026#34;Error processing item {item[\u0026#39;itemId\u0026#39;]}: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: f\u0026#39;Error processing item {item[\u0026#34;itemId\u0026#34;]}\u0026#39;}) # Create OrderPlaced event event_id = str(uuid.uuid4()) timestamp = datetime.utcnow().isoformat() event_data = { \u0026#39;eventId\u0026#39;: event_id, \u0026#39;aggregateId\u0026#39;: order_id, \u0026#39;eventType\u0026#39;: \u0026#39;OrderPlaced\u0026#39;, \u0026#39;eventData\u0026#39;: { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;customerName\u0026#39;: order_data[\u0026#39;customerName\u0026#39;], \u0026#39;customerPhone\u0026#39;: order_data[\u0026#39;customerPhone\u0026#39;], \u0026#39;customerAddress\u0026#39;: order_data[\u0026#39;customerAddress\u0026#39;], \u0026#39;items\u0026#39;: validated_items, \u0026#39;totalAmount\u0026#39;: total_amount, # Keep as Decimal for DynamoDB \u0026#39;status\u0026#39;: \u0026#39;PLACED\u0026#39;, \u0026#39;timestamp\u0026#39;: timestamp }, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;version\u0026#39;: 1 } try: # Store event in Event Store event_store_table.put_item(Item=event_data) print(f\u0026#34;Event stored successfully in EventStore\u0026#34;) # Publish event to EventBridge (convert Decimals to float for JSON serialization) publish_event_to_bridge(event_data) print(f\u0026#34;Event published to EventBridge successfully\u0026#34;) return build_response(201, { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;message\u0026#39;: \u0026#39;Order placed successfully\u0026#39;, \u0026#39;totalAmount\u0026#39;: float(total_amount), # Convert to float for JSON response \u0026#39;items\u0026#39;: convert_decimals_to_float(validated_items), # Convert for JSON response \u0026#39;status\u0026#39;: \u0026#39;PLACED\u0026#39; }) except Exception as e: print(f\u0026#34;Error storing event: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to process order\u0026#39;}) def handle_confirm_order(confirm_data): order_id = confirm_data.get(\u0026#39;orderId\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Order ID required\u0026#39;}) # Calculate estimated delivery time (30 minutes from now) estimated_delivery = (datetime.utcnow() + timedelta(minutes=30)).isoformat() # Create OrderConfirmed event event_id = str(uuid.uuid4()) timestamp = datetime.utcnow().isoformat() event_data = { \u0026#39;eventId\u0026#39;: event_id, \u0026#39;aggregateId\u0026#39;: order_id, \u0026#39;eventType\u0026#39;: \u0026#39;OrderConfirmed\u0026#39;, \u0026#39;eventData\u0026#39;: { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;confirmedAt\u0026#39;: timestamp, \u0026#39;estimatedDelivery\u0026#39;: estimated_delivery, \u0026#39;status\u0026#39;: \u0026#39;CONFIRMED\u0026#39; }, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;version\u0026#39;: 1 } try: # Store event event_store_table.put_item(Item=event_data) # Publish event publish_event_to_bridge(event_data) return build_response(200, { \u0026#39;message\u0026#39;: \u0026#39;Order confirmed successfully\u0026#39;, \u0026#39;estimatedDelivery\u0026#39;: estimated_delivery }) except Exception as e: print(f\u0026#34;Error confirming order: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to confirm order\u0026#39;}) def handle_cancel_order(cancel_data): order_id = cancel_data.get(\u0026#39;orderId\u0026#39;) reason = cancel_data.get(\u0026#39;reason\u0026#39;, \u0026#39;Customer request\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Order ID required\u0026#39;}) # Create OrderCancelled event event_id = str(uuid.uuid4()) timestamp = datetime.utcnow().isoformat() event_data = { \u0026#39;eventId\u0026#39;: event_id, \u0026#39;aggregateId\u0026#39;: order_id, \u0026#39;eventType\u0026#39;: \u0026#39;OrderCancelled\u0026#39;, \u0026#39;eventData\u0026#39;: { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;cancelledAt\u0026#39;: timestamp, \u0026#39;reason\u0026#39;: reason, \u0026#39;status\u0026#39;: \u0026#39;CANCELLED\u0026#39; }, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;version\u0026#39;: 1 } try: # Store event event_store_table.put_item(Item=event_data) # Publish event publish_event_to_bridge(event_data) return build_response(200, { \u0026#39;message\u0026#39;: \u0026#39;Order cancelled successfully\u0026#39;, \u0026#39;reason\u0026#39;: reason }) except Exception as e: print(f\u0026#34;Error cancelling order: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to cancel order\u0026#39;}) def publish_event_to_bridge(event_data): try: # Convert Decimal values to float for JSON serialization event_data_for_bridge = convert_decimals_to_float(event_data[\u0026#39;eventData\u0026#39;]) print(f\u0026#34;Publishing event to EventBridge: {event_data[\u0026#39;eventType\u0026#39;]}\u0026#34;) print(f\u0026#34;Event data: {event_data_for_bridge}\u0026#34;) response = eventbridge.put_events( Entries=[ { \u0026#39;Source\u0026#39;: \u0026#39;fastfood.orders\u0026#39;, \u0026#39;DetailType\u0026#39;: event_data[\u0026#39;eventType\u0026#39;], \u0026#39;Detail\u0026#39;: json.dumps(event_data_for_bridge, default=str), \u0026#39;EventBusName\u0026#39;: \u0026#39;FastFoodOrderBus\u0026#39; } ] ) print(f\u0026#34;EventBridge response: {response}\u0026#34;) # Check if there were any failures if response.get(\u0026#39;FailedEntryCount\u0026#39;, 0) \u0026gt; 0: print(f\u0026#34;Failed to publish some events: {response.get(\u0026#39;Entries\u0026#39;, [])}\u0026#34;) raise Exception(\u0026#34;Failed to publish event to EventBridge\u0026#34;) except Exception as e: print(f\u0026#34;Error publishing event to EventBridge: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def convert_decimals_to_float(obj): \u0026#34;\u0026#34;\u0026#34; Recursively convert Decimal objects to float for JSON serialization \u0026#34;\u0026#34;\u0026#34; if isinstance(obj, list): return [convert_decimals_to_float(item) for item in obj] elif isinstance(obj, dict): return {key: convert_decimals_to_float(value) for key, value in obj.items()} elif isinstance(obj, Decimal): return float(obj) else: return obj def build_response(status_code, body): return { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, PUT, DELETE, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(body, default=str) } Nhấn Deploy để lưu mã hàm. ✅ Kết quả: Hàm Lambda OrderCommandHandler đã được tạo thành công và sẵn sàng xử lý các lệnh đặt hàng.\n"
},
{
	"uri": "/vi/6-configapigateway/6.2-enable-cors/",
	"title": "Bật CORS",
	"tags": [],
	"description": "",
	"content": "\rTrong bước này, chúng ta sẽ bật Cross-Origin Resource Sharing (CORS) cho các tài nguyên trong API Gateway.\nĐiều này cho phép các ứng dụng web được lưu trữ trên những domain khác nhau có thể gọi API của chúng ta một cách an toàn.\nBước 1: Bật CORS cho từng Resource Thực hiện các bước sau cho từng resource:\n/orders /orders/{id} /orders/confirm /orders/cancel /menu /customers /reconstruct /reconstruct/order /reconstruct/all Chọn resource trong API Gateway Console.\nNhấp Enable CORS.\nCấu hình CORS như sau:\nAccess-Control-Allow-Origin: * Access-Control-Allow-Headers: Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token Access-Control-Allow-Methods: Chọn tất cả các HTTP method có sẵn. Nhấp Enable CORS and replace existing CORS headers.\nLặp lại các bước này cho từng resource để đảm bảo CORS được cấu hình đầy đủ trên toàn bộ API.\n"
},
{
	"uri": "/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ chuẩn bị môi trường cần thiết cho workshop, bao gồm cài đặt Node.js, thiết lập mã nguồn frontend, và tạo IAM Role cho các dịch vụ AWS.\nNội dung 2.1. Cài đặt Node.js 2.2. Thiết lập mã nguồn Frontend 2.3. Tạo IAM Role\n"
},
{
	"uri": "/vi/2-prerequiste/2.2-setup-frontend-source/",
	"title": "Cài đặt Frontend",
	"tags": [],
	"description": "",
	"content": "Cài đặt mã nguồn Frontend Clone dự án từ GitHub: git clone https://github.com/khanhchi423/fastfood-order-frontend.git Di chuyển vào thư mục dự án: cd fastfood-order-frontend Cài đặt các thư viện phụ thuộc của dự án bằng npm: npm install Khởi động máy chủ phát triển: npm run dev Nếu máy chủ chạy thành công, bạn sẽ thấy thông báo cho biết ứng dụng đang chạy, thường tại: http://localhost:3000 Mở URL này trong trình duyệt của bạn để xem ứng dụng frontend. "
},
{
	"uri": "/vi/5-setupeventbridge/5.1-customeventbus/5.1.1-configure-eventbridge-rules/",
	"title": "Cấu hình EventBridge Rules",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo một EventBridge rule hỗ trợ kiến trúc Event Sourcing bằng cách thu thập các domain events từ custom event bus. Rule này sẽ định tuyến các sự kiện đơn hàng (OrderPlaced, OrderConfirmed, OrderCancelled) đến Lambda function, nơi chúng sẽ được xử lý để cập nhật read models và duy trì event store — một thành phần cốt lõi của mô hình Event Sourcing.\nBước 1: Điều hướng đến EventBridge Rules Trong Amazon EventBridge console, nhấp vào Rules ở thanh điều hướng bên trái. Nhấp Create rule. Bước 2: Xác định Thông tin Rule Name: OrderEventProcessingRule Description: Process all order events Event bus: Chọn FastFoodOrderBus từ danh sách thả xuống Rule type: Chọn Rule with an event pattern Nhấp Next. Bước 3: Tạo Event Pattern Creation method: Chọn Custom pattern (JSON editor) Trong ô Event pattern, nhập JSON sau: { \u0026#34;source\u0026#34;: [\u0026#34;fastfood.orders\u0026#34;], \u0026#34;detail-type\u0026#34;: [ \u0026#34;OrderPlaced\u0026#34;, \u0026#34;OrderConfirmed\u0026#34;, \u0026#34;OrderCancelled\u0026#34; ] } Xác minh rằng chỉ báo JSON is valid hiển thị dấu ✔️ màu xanh. Nhấp Next. Bước 4: Cấu hình Target Target type: Chọn AWS service Select a service: Chọn Lambda function Function: Chọn OrderEventProcessor từ danh sách thả xuống Giữ nguyên các thiết lập khác mặc định. Nhấp Next. Bước 5: Cấu hình Tags (Tuỳ chọn) Bước này là tùy chọn. Bạn có thể thêm tags để tổ chức và quản lý EventBridge rule. Nhấp Next để tiếp tục. Bước 6: Xem lại và Tạo Kiểm tra lại toàn bộ thông tin cấu hình:\nRule name: OrderEventProcessingRule Event bus: FastFoodOrderBus Event pattern: Bắt các sự kiện fastfood.orders Target: Lambda function OrderEventProcessor Nhấp Create rule.\n✅ Kết quả: EventBridge rule đã được tạo thành công và sẽ tự động định tuyến các sự kiện đơn hàng từ FastFoodOrderBus đến Lambda function OrderEventProcessor để xử lý.\nTạo StateReconstructionRule Tiếp theo, chúng ta sẽ tạo một rule thứ hai để xử lý yêu cầu khôi phục trạng thái.\nBước 7: Tạo Rule Thứ Hai Nhấp Create rule một lần nữa để tạo rule mới.\nCấu hình thông tin rule:\nName: StateReconstructionRule Description: Handle state reconstruction requests Event bus: Chọn FastFoodOrderBus từ danh sách thả xuống Rule type: Chọn Rule with an event pattern\nNhấp Next.\nBước 8: Tạo Event Pattern cho State Reconstruction Creation method: Chọn Custom pattern (JSON editor) Trong ô Event pattern, nhập JSON sau: { \u0026#34;source\u0026#34;: [\u0026#34;fastfood.orders\u0026#34;], \u0026#34;detail-type\u0026#34;: [ \u0026#34;OrderPlaced\u0026#34;, \u0026#34;OrderConfirmed\u0026#34;, \u0026#34;OrderCancelled\u0026#34; ] } Xác minh rằng chỉ báo JSON is valid hiển thị dấu ✔️ màu xanh.\nNhấp Next.\nBước 9: Cấu hình Target cho State Reconstruction Target type: Chọn AWS service Select a service: Chọn Lambda function Function: Chọn StateReconstructionHandler từ danh sách thả xuống Giữ nguyên các thiết lập mặc định khác Nhấp Next\nBước 10: Xem lại và Tạo State Reconstruction Rule Xem lại toàn bộ thông tin cấu hình:\nRule name: StateReconstructionRule Event bus: FastFoodOrderBus Event pattern: Bắt các sự kiện fastfood.orders Target: Lambda function StateReconstructionHandler 📌 Lưu ý: Trong ảnh minh họa trên, Rule ARN chỉ là ví dụ.\nHãy sao chép Rule ARN của StateReconstructionRule trong tài khoản AWS của bạn.\nBạn có thể tìm thấy ARN này trong EventBridge console → Chọn rule của bạn → Rule ARN (được đánh dấu khung đỏ).\nCấu hình Quyền cho Lambda Function Sau khi tạo EventBridge rule, cần đảm bảo Lambda function có quyền được EventBridge gọi.\nVào Lambda Console → Functions → StateReconstructionHandler\nChuyển đến tab Configuration → Permissions\nVào mục Resource-based policy statements → Add permissions\nThêm quyền Invoke từ EventBridge\nService: Chọn EventBridge (CloudWatch Events) Statement ID: AllowEventBridgeInvokeStateReconstruction Principal: events.amazonaws.com Source ARN: arn:aws:events:ap-southeast-1:218451864254:rule/FastFoodOrderBus/StateReconstructionRule Action: lambda:InvokeFunction** ARN trên chỉ là ví dụ. Hãy thay bằng ARN của StateReconstructionRule mà bạn đã tạo trong AWS account của mình.\nNhấp Save để áp dụng quyền. Cấu hình quyền này dành cho Lambda function StateReconstructionHandler.\nCách thiết lập tương tự như phần quyền của OrderEventProcessor trước đó, chỉ khác tên function và EventBridge rule liên kết.\nNgữ cảnh Event Sourcing:\nRule này đóng vai trò quan trọng trong triển khai Event Sourcing.\nKhi các domain events (OrderPlaced, OrderConfirmed, OrderCancelled) được publish lên FastFoodOrderBus, chúng thể hiện các thay đổi trạng thái trong hệ thống.\nLambda function sẽ xử lý các sự kiện này để:\nLưu chúng vào event store (DynamoDB) Cập nhật read models để phục vụ truy vấn Có thể kích hoạt side effects hoặc gửi thông báo Điều này cho phép chúng ta tái tạo lại trạng thái ứng dụng từ chuỗi sự kiện — nguyên tắc cốt lõi của Event Sourcing.\n"
},
{
	"uri": "/vi/8-testing/8.2-monitoring/",
	"title": "Giám sát với CloudWatch",
	"tags": [],
	"description": "",
	"content": "Bước 1: Truy cập bảng điều khiển CloudWatch Trong AWS Management Console, tìm kiếm CloudWatch. Nhấp vào CloudWatch để mở dịch vụ giám sát. Bước 2: Xem các nhóm Log Trong bảng điều khiển CloudWatch, điều hướng đến Logs → Log groups.\nBạn sẽ thấy 4 nhóm log được tạo cho các hàm Lambda của bạn:\n/aws/lambda/OrderCommandHandler /aws/lambda/OrderEventProcessor /aws/lambda/OrderQueryHandler /aws/lambda/StateReconstructionHandler Mỗi nhóm log hiển thị loại log, thời gian giữ log (Retention), và các cấu hình khác. Bước 3: Giám sát log của hàm Lambda Nhấp vào nhóm log /aws/lambda/StateReconstructionHandler.\nBạn có thể xem chi tiết nhóm log bao gồm:\nThời gian tạo: Thời điểm nhóm log được tạo Thời gian giữ: Không bao giờ hết hạn (mặc định) Dung lượng lưu trữ: Lượng dữ liệu log đã lưu ARN: Amazon Resource Name của nhóm log Hình trên minh họa giao diện xem Log events cho hàm Lambda StateReconstructionHandler trên AWS CloudWatch. Mỗi mục log được hiển thị theo thứ tự thời gian, chứa thông tin về các sự kiện nhận được từ EventBridge (ví dụ: OrderPlaced, OrderConfirmed, OrderCancelled), quá trình tái tạo trạng thái đơn hàng từ EventStore, và cập nhật Read Model tương ứng. Các log cũng cung cấp các chỉ số hiệu suất như thời gian thực thi, bộ nhớ sử dụng và thời gian khởi tạo hàm Lambda. Việc giám sát chi tiết này giúp đội phát triển xác minh tính chính xác của luồng xử lý sự kiện, đảm bảo tính nhất quán dữ liệu và phát hiện các điểm nghẽn về hiệu suất để tối ưu hóa.\n"
},
{
	"uri": "/vi/7-deployfrontend/7.2-upload-frontend-to-s3/",
	"title": "Tải Frontend lên S3",
	"tags": [],
	"description": "",
	"content": "Tải ReactJS Frontend lên S3 (Các bước chi tiết) Bước 1: Cấu hình API URL trong React Trước khi build frontend, hãy thiết lập biến môi trường trong file .env hoặc trực tiếp trong môi trường của bạn:\nVITE_API_BASE_URL=https://0nxpvdebt3.execute-api.ap-southeast-1.amazonaws.com/prod VITE_USE_MOCK_DATA=true Cập nhật file cấu hình src/config/config.js để sử dụng các biến môi trường này:\nconst config = { // API Configuration API_BASE_URL: import.meta.env.VITE_API_BASE_URL || \u0026#39;https://0nxpvdebt3.execute-api.ap-southeast-1.amazonaws.com/prod\u0026#39;, // Development mode - set to true to use mock data instead of API USE_MOCK_DATA: import.meta.env.VITE_USE_MOCK_DATA === \u0026#39;true\u0026#39; || false, // Other configurations APP_NAME: \u0026#39;FastFood Order System\u0026#39;, APP_VERSION: \u0026#39;1.0.0\u0026#39;, // Request timeout (in milliseconds) REQUEST_TIMEOUT: 10000, // Auto-refresh intervals (in milliseconds) ORDER_REFRESH_INTERVAL: 30000, // 30 seconds MENU_REFRESH_INTERVAL: 300000, // 5 minutes }; export default config; Thay thế API URL mặc định (https://0nxpvdebt3.execute-api.ap-southeast-1.amazonaws.com/prod) bằng API Gateway invoke URL thực tế mà bạn đã tạo cho lần triển khai của mình.\nBước 2: Build Frontend Chạy lệnh build để tạo ra các tệp sẵn sàng cho môi trường production:\nnpm run build Bước 3: Tải thư mục Build lên S3 Mở S3 Console trong AWS. Chọn S3 bucket chứa frontend của bạn. Nhấp Upload → Add folder. Chọn thư mục build từ dự án React của bạn. Tải toàn bộ nội dung bên trong thư mục build lên. Kiểm tra website bằng endpoint. "
},
{
	"uri": "/vi/3-eventstore/3.2-create-orderreadmodel-table/",
	"title": "Tạo bảng OrderReadModel",
	"tags": [],
	"description": "",
	"content": "Lặp lại các bước tương tự như khi tạo EventStore.\nBước 1: Tạo bảng mới Trong DynamoDB Console, nhấn Create table. Table name: OrderReadModel Partition key: orderId (String) Chọn Default settings. Nhấn Create table. ✅ Kết quả: Bảng OrderReadModel đã sẵn sàng để lưu trữ dữ liệu đơn hàng.\n"
},
{
	"uri": "/vi/2-prerequiste/2.3-create-iam-role/",
	"title": "Tạo IAM Role",
	"tags": [],
	"description": "",
	"content": "Bước 1: Mở IAM Console Trong AWS Management Console, tìm kiếm IAM. Nhấn vào IAM để mở trang quản trị IAM. Bước 2: Tạo Role Vào Roles → Create role.\nTrong Trusted entity type, chọn AWS service.\nChọn Lambda làm dịch vụ.\nNhấn Next.\nNhấn Create Role.\n"
},
{
	"uri": "/vi/4-deploylambda/4.2.-implementfunctionordereventprocessor/",
	"title": "Triển khai OrderEventProcessor",
	"tags": [],
	"description": "",
	"content": "Tiếp theo, chúng ta sẽ tạo OrderEventProcessor — hàm Lambda chịu trách nhiệm lắng nghe các sự kiện đơn hàng và cập nhật OrderReadModel tương ứng.\nCác bước tạo hàm này tương tự như phần trước.\nBước 1: Tạo hàm Lambda Chọn Author from scratch. Nhập tên hàm: OrderEventProcessor. Chọn Runtime: Python 3.12. Chọn Architecture: x86_64. Chọn Use an existing role và chọn EventSourcingLambdaRole. Nhấn Create function. Bước 2: Triển khai mã hàm Thay thế mã mặc định bằng nội dung sau: import json import boto3 from decimal import Decimal from datetime import datetime # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) sns = boto3.client(\u0026#39;sns\u0026#39;) # DynamoDB tables order_table = dynamodb.Table(\u0026#39;OrderReadModel\u0026#39;) customer_table = dynamodb.Table(\u0026#39;CustomerReadModel\u0026#39;) # SNS Topic ARN - Replace with your actual SNS topic ARN SNS_TOPIC_ARN = \u0026#39;arn:aws:sns:ap-southeast-1:218451864254:OrderNotifications\u0026#39; def lambda_handler(event, context): try: print(f\u0026#34;Received event: {json.dumps(event)}\u0026#34;) # Handle EventBridge events if \u0026#39;detail-type\u0026#39; in event and \u0026#39;detail\u0026#39; in event: process_eventbridge_event(event) # Handle direct invocation or other event sources elif \u0026#39;Records\u0026#39; in event: for record in event[\u0026#39;Records\u0026#39;]: if \u0026#39;eventbridge\u0026#39; in record.get(\u0026#39;eventSource\u0026#39;, \u0026#39;\u0026#39;): process_eventbridge_event(json.loads(record[\u0026#39;body\u0026#39;])) else: # Direct EventBridge invocation process_eventbridge_event(event) return {\u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: \u0026#39;Events processed successfully\u0026#39;} except Exception as e: print(f\u0026#34;Error processing events: {str(e)}\u0026#34;) import traceback traceback.print_exc() return {\u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: \u0026#39;Error processing events\u0026#39;} def process_eventbridge_event(event_data): detail_type = event_data.get(\u0026#39;detail-type\u0026#39;) detail = event_data.get(\u0026#39;detail\u0026#39;, {}) print(f\u0026#34;Processing event type: {detail_type}\u0026#34;) print(f\u0026#34;Event detail: {detail}\u0026#34;) if detail_type == \u0026#39;OrderPlaced\u0026#39;: handle_order_placed(detail) elif detail_type == \u0026#39;OrderConfirmed\u0026#39;: handle_order_confirmed(detail) elif detail_type == \u0026#39;OrderCancelled\u0026#39;: handle_order_cancelled(detail) else: print(f\u0026#34;Unknown event type: {detail_type}\u0026#34;) def handle_order_placed(detail): try: # Convert float values back to Decimal for DynamoDB items = [] for item in detail.get(\u0026#39;items\u0026#39;, []): items.append({ \u0026#39;itemId\u0026#39;: item[\u0026#39;itemId\u0026#39;], \u0026#39;name\u0026#39;: item[\u0026#39;name\u0026#39;], \u0026#39;price\u0026#39;: Decimal(str(item[\u0026#39;price\u0026#39;])), \u0026#39;quantity\u0026#39;: item[\u0026#39;quantity\u0026#39;], \u0026#39;total\u0026#39;: Decimal(str(item[\u0026#39;total\u0026#39;])) }) # Create order record in read model order_item = { \u0026#39;orderId\u0026#39;: detail[\u0026#39;orderId\u0026#39;], \u0026#39;customerName\u0026#39;: detail[\u0026#39;customerName\u0026#39;], \u0026#39;customerPhone\u0026#39;: detail[\u0026#39;customerPhone\u0026#39;], \u0026#39;customerAddress\u0026#39;: detail[\u0026#39;customerAddress\u0026#39;], \u0026#39;items\u0026#39;: items, \u0026#39;totalAmount\u0026#39;: Decimal(str(detail[\u0026#39;totalAmount\u0026#39;])), \u0026#39;status\u0026#39;: \u0026#39;PLACED\u0026#39;, \u0026#39;createdAt\u0026#39;: detail.get(\u0026#39;timestamp\u0026#39;, datetime.utcnow().isoformat()), \u0026#39;updatedAt\u0026#39;: detail.get(\u0026#39;timestamp\u0026#39;, datetime.utcnow().isoformat()) } order_table.put_item(Item=order_item) print(f\u0026#34;Order {detail[\u0026#39;orderId\u0026#39;]} created in read model\u0026#34;) # Update customer record customer_id = detail[\u0026#39;customerPhone\u0026#39;] # Use phone as customer ID try: customer_table.update_item( Key={\u0026#39;customerId\u0026#39;: customer_id}, UpdateExpression=\u0026#39;SET customerName = :name, customerPhone = :phone, totalOrders = if_not_exists(totalOrders, :zero) + :one, updatedAt = :updated\u0026#39;, ExpressionAttributeValues={ \u0026#39;:name\u0026#39;: detail[\u0026#39;customerName\u0026#39;], \u0026#39;:phone\u0026#39;: detail[\u0026#39;customerPhone\u0026#39;], \u0026#39;:zero\u0026#39;: 0, \u0026#39;:one\u0026#39;: 1, \u0026#39;:updated\u0026#39;: datetime.utcnow().isoformat() } ) print(f\u0026#34;Customer {customer_id} updated\u0026#34;) except Exception as e: print(f\u0026#34;Error updating customer: {str(e)}\u0026#34;) # Gửi thông báo cho admin send_notification( f\u0026#34;[ADMIN] New Order Placed - #{detail[\u0026#39;orderId\u0026#39;][:8]}\u0026#34;, ( f\u0026#34;A new customer order has been placed.\\n\u0026#34; f\u0026#34;Order ID: {detail[\u0026#39;orderId\u0026#39;]}\\n\u0026#34; f\u0026#34;Customer: {detail[\u0026#39;customerName\u0026#39;]}\\n\u0026#34; f\u0026#34;Phone: {detail[\u0026#39;customerPhone\u0026#39;]}\\n\u0026#34; f\u0026#34;Total: ${detail[\u0026#39;totalAmount\u0026#39;]:.2f}\\n\u0026#34; f\u0026#34;Status: PLACED\u0026#34; ) ) except Exception as e: print(f\u0026#34;Error handling OrderPlaced: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def handle_order_confirmed(detail): try: order_table.update_item( Key={\u0026#39;orderId\u0026#39;: detail[\u0026#39;orderId\u0026#39;]}, UpdateExpression=\u0026#39;SET #status = :status, confirmedAt = :confirmed_at, estimatedDelivery = :estimated, updatedAt = :updated\u0026#39;, ExpressionAttributeNames={\u0026#39;#status\u0026#39;: \u0026#39;status\u0026#39;}, ExpressionAttributeValues={ \u0026#39;:status\u0026#39;: \u0026#39;CONFIRMED\u0026#39;, \u0026#39;:confirmed_at\u0026#39;: detail.get(\u0026#39;confirmedAt\u0026#39;), \u0026#39;:estimated\u0026#39;: detail.get(\u0026#39;estimatedDelivery\u0026#39;), \u0026#39;:updated\u0026#39;: datetime.utcnow().isoformat() } ) print(f\u0026#34;Order {detail[\u0026#39;orderId\u0026#39;]} confirmed\u0026#34;) # Gửi thông báo cho admin send_notification( f\u0026#34;[ADMIN] Order Confirmed - #{detail[\u0026#39;orderId\u0026#39;][:8]}\u0026#34;, ( f\u0026#34;Customer order has been confirmed.\\n\u0026#34; f\u0026#34;Order ID: {detail[\u0026#39;orderId\u0026#39;]}\\n\u0026#34; f\u0026#34;Estimated Delivery: {detail.get(\u0026#39;estimatedDelivery\u0026#39;, \u0026#39;TBD\u0026#39;)}\u0026#34; ) ) except Exception as e: print(f\u0026#34;Error handling OrderConfirmed: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def handle_order_cancelled(detail): try: order_table.update_item( Key={\u0026#39;orderId\u0026#39;: detail[\u0026#39;orderId\u0026#39;]}, UpdateExpression=\u0026#39;SET #status = :status, cancelledAt = :cancelled_at, cancelReason = :reason, updatedAt = :updated\u0026#39;, ExpressionAttributeNames={\u0026#39;#status\u0026#39;: \u0026#39;status\u0026#39;}, ExpressionAttributeValues={ \u0026#39;:status\u0026#39;: \u0026#39;CANCELLED\u0026#39;, \u0026#39;:cancelled_at\u0026#39;: detail.get(\u0026#39;cancelledAt\u0026#39;), \u0026#39;:reason\u0026#39;: detail.get(\u0026#39;reason\u0026#39;), \u0026#39;:updated\u0026#39;: datetime.utcnow().isoformat() } ) print(f\u0026#34;Order {detail[\u0026#39;orderId\u0026#39;]} cancelled\u0026#34;) # Gửi thông báo cho admin send_notification( f\u0026#34;[ADMIN] Order Cancelled - #{detail[\u0026#39;orderId\u0026#39;][:8]}\u0026#34;, ( f\u0026#34;Customer order has been cancelled.\\n\u0026#34; f\u0026#34;Order ID: {detail[\u0026#39;orderId\u0026#39;]}\\n\u0026#34; f\u0026#34;Reason: {detail.get(\u0026#39;reason\u0026#39;, \u0026#39;No reason provided\u0026#39;)}\u0026#34; ) ) except Exception as e: print(f\u0026#34;Error handling OrderCancelled: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def send_notification(subject, message): try: print(f\u0026#34;NOTIFICATION - {subject}: {message}\u0026#34;) sns.publish( TopicArn=SNS_TOPIC_ARN, Subject=str(subject), Message=str(message) ) except Exception as e: print(f\u0026#34;Error sending notification: {str(e)}\u0026#34;) import traceback traceback.print_exc() # Không raise để Lambda tiếp tục chạy Nhấn Deploy để lưu mã hàm.\n✅ Hàm Lambda OrderEventProcessor hiện đã sẵn sàng để xử lý các sự kiện đơn hàng và cập nhật read model.\n"
},
{
	"uri": "/vi/3-eventstore/3.3-create-customerreadmodel-table/",
	"title": "Tạo bảng CustomerReadModel",
	"tags": [],
	"description": "",
	"content": "Bước 1: Tạo bảng mới Trong DynamoDB Console, nhấn Create table. Table name: CustomerReadModel Partition key: customerId (String) Chọn Default settings. Nhấn Create table. ✅ Kết quả: Bảng CustomerReadModel đã sẵn sàng để lưu trữ thông tin khách hàng.\n"
},
{
	"uri": "/vi/7-deployfrontend/7.3-create-cloudfrontdistributionandapplyittothewebsite/",
	"title": "Tạo CloudFront Distribution và Áp dụng cho Website",
	"tags": [],
	"description": "",
	"content": "Tạo CloudFront Distribution để Phân Phối Nội Dung Toàn Cầu CloudFront là mạng phân phối nội dung (CDN) của Amazon giúp tăng tốc phân phối nội dung web tĩnh và động của bạn tới người dùng trên toàn thế giới. Trong phần này, chúng ta sẽ tạo một CloudFront distribution cho ứng dụng React của mình.\nBước 1: Truy cập Dịch vụ CloudFront Điều hướng đến AWS Management Console và tìm kiếm \u0026ldquo;CloudFront\u0026rdquo; trong thanh tìm kiếm. Nhấp vào CloudFront để mở bảng điều khiển dịch vụ. Nhấp Create a CloudFront distribution để bắt đầu quá trình thiết lập. Bước 2: Cấu hình Distribution Tùy chọn Distribution\nDistribution name: Nhập tên mô tả cho distribution của bạn: fastfood-react-app Description (tùy chọn): Thêm mô tả ngắn gọn: FastFood Order System - React App Distribution type: Chọn Single website or app vì chúng ta đang triển khai một ứng dụng React duy nhất. Tên miền tùy chỉnh (Optional)\nNếu bạn có tên miền riêng, bạn có thể cấu hình ở đây. Nếu không, hãy để trống để sử dụng tên miền mặc định của CloudFront.\nDomain (tùy chọn): Để trống hoặc nhập tên miền tùy chỉnh nếu bạn có. Nhấp Check domain nếu bạn đã nhập tên miền để kiểm tra tính khả dụng. Bước 3: Chỉ định Cấu hình Origin Origin là nơi CloudFront lấy nội dung của bạn — trong trường hợp này là S3 bucket.\nOrigin type: Chọn Amazon S3 vì chúng ta sẽ phục vụ nội dung từ S3 bucket. S3 origin: Nhập endpoint của S3 bucket:\nevent-sourcing-fastfood-frontend-s3-website-ap-southeast-1.amazonaws.com Origin path (tùy chọn): Giữ nguyên /path hoặc chỉnh sửa nếu nội dung của bạn nằm trong thư mục con. Bước 4: Cấu hình Bảo mật Web Application Firewall (WAF)\nTrong hướng dẫn này, chúng ta sẽ tắt WAF để giảm chi phí:\nWeb Application Firewall (WAF): Chọn Do not enable security protections. Tùy chọn này phù hợp cho môi trường phát triển và thử nghiệm. Với ứng dụng sản xuất, hãy cân nhắc bật WAF để tăng cường bảo mật. Bước 5: Xem lại và Tạo Distribution Xem lại toàn bộ cấu hình để đảm bảo chính xác. Nhấp Next để tiếp tục sang trang xem lại cuối cùng. Nhấp Create distribution để triển khai CloudFront distribution. Quá trình triển khai CloudFront distribution thường mất 15–20 phút. Trạng thái sẽ chuyển từ Deploying sang Enabled khi hoàn tất.\nCập nhật Bucket Policy của S3 Quay lại S3 bucket: event-sourcing-fastfood-frontend Vào tab Permissions Nhấp vào Bucket policy để chỉnh sửa policy hiện tại Cập nhật policy để bao gồm quyền truy cập từ CloudFront\nPolicy sau khi cập nhật sẽ như sau: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::event-sourcing-fastfood-frontend/*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowCloudFrontServicePrincipal\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;cloudfront.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::event-sourcing-fastfood-frontend/*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:aws:cloudfront::218453064234:distribution/E2MQTT186060K\u0026#34; } } } ] } Nhấp Save changes để áp dụng policy đã cập nhật\nTruy cập Ứng dụng của Bạn qua CloudFront Khi CloudFront distribution đã được triển khai và bucket policy đã được cập nhật, bạn có thể truy cập ứng dụng React thông qua URL của CloudFront.\nKiểm tra CloudFront Distribution\nSao chép Distribution domain name từ bảng điều khiển CloudFront (ví dụ: d26xve6snn0mdw.cloudfront.net) Mở một tab trình duyệt mới và truy cập vào URL CloudFront Xác minh rằng hệ thống Fast Food của bạn hiển thị chính xác Bạn sẽ thấy ứng dụng React của mình như sau:\n"
},
{
	"uri": "/vi/5-setupeventbridge/5.2-create-sns-topic-for-notifications/",
	"title": "Tạo SNS Topic cho Thông báo",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo một SNS (Simple Notification Service) Topic\nđể xử lý các thông báo được kích hoạt bởi các sự kiện đơn hàng.\nTopic này sẽ đóng vai trò là trung tâm truyền thông để phát đi các cập nhật trạng thái đơn hàng tới những người đăng ký,\nhỗ trợ kiến trúc Event Sourcing bằng cách cung cấp thông báo thời gian thực khi các sự kiện domain xảy ra.\nBước 1: Truy cập SNS Console Trong AWS Management Console, tìm kiếm từ khóa SNS. Nhấn Simple Notification Service để mở dịch vụ. Bước 2: Tạo SNS Topic Trong SNS console, chọn Topics ở bảng điều hướng bên trái. Nhấn Create topic. Bước 3: Cấu hình chi tiết Topic Type: Chọn Standard (khuyến nghị cho hiệu suất cao và sắp xếp thông điệp theo kiểu “best-effort”) Name: Nhập OrderNotifications Display name: Nhập Order Notifications (tùy chọn – dùng cho subscription qua SMS) Giữ nguyên các thiết lập khác mặc định. Nhấn Create topic. ✅ Kết quả: Topic OrderNotifications đã được tạo thành công và sẵn sàng xử lý thông báo.\nBước 4: Tạo Email Subscription Điều hướng đến topic OrderNotifications vừa tạo. Nhấn Create subscription. Bước 5: Cấu hình chi tiết Subscription Topic ARN: Tự động hiển thị ARN của topic OrderNotifications Protocol: Chọn Email Endpoint: Nhập địa chỉ email của bạn (ví dụ: your-email@gmail.com) Giữ nguyên các thiết lập tùy chọn khác. Nhấn Create subscription. Bước 6: Xác nhận Email Subscription Mở hộp thư email của bạn và tìm email từ AWS Notifications – Subscription Confirmation. Nhấn Confirm subscription trong email để kích hoạt đăng ký. Sau khi xác nhận, trạng thái của subscription sẽ chuyển sang Confirmed. Bước 7: Liên kết SNS Topic ARN với Lambda Sau khi tạo SNS topic và xác nhận subscription, bạn cần liên kết nó với hàm Lambda OrderEventProcessor\nđể Lambda có thể gửi thông báo.\nMở AWS Lambda Console và tìm tới hàm OrderEventProcessor. Trong tab Code, tìm biến SNS_TOPIC_ARN. Thay thế giá trị placeholder bằng ARN của SNS topic vừa tạo. "
},
{
	"uri": "/vi/3-eventstore/",
	"title": "Thiết lập Event Store &amp; Read Models (DynamoDB)",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ tạo các bảng DynamoDB cần thiết cho kiến trúc Event Sourcing và khởi tạo dữ liệu ban đầu cho bảng MenuItems.\nNội dung 3.1. Tạo bảng EventStore 3.2. Tạo bảng OrderReadModel 3.3. Tạo bảng CustomerReadModel 3.4. Tạo bảng MenuItems 3.5. Khởi tạo dữ liệu cho MenuItems\n"
},
{
	"uri": "/vi/6-configapigateway/6.3-deploy-api/",
	"title": "Triển khai API",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ triển khai API Gateway đã cấu hình để có thể truy cập từ client thông qua một URL công khai.\nBước 1: Triển khai API Trong API Gateway Console, nhấp Actions → Deploy API.\nCấu hình thông tin triển khai:\nDeployment stage: Chọn [New Stage]. Stage name: Nhập prod. Stage description: Nhập Production stage. Deployment description: Nhập Initial deployment. Nhấp Deploy.\nBước 2: Lưu API URL Sau khi triển khai, Invoke URL sẽ xuất hiện ở phía trên.\nHãy sao chép và lưu lại URL này để sử dụng sau trong ứng dụng client.\nVí dụ:\nhttps://your-api-id.execute-api.ap-southeast-1.amazonaws.com/prod "
},
{
	"uri": "/vi/4-deploylambda/4.3.-implementfunctionorderqueryhandler/",
	"title": "Triển khai OrderQueryHandler",
	"tags": [],
	"description": "",
	"content": "Tiếp theo, chúng ta sẽ tạo hàm Lambda OrderQueryHandler để xử lý các yêu cầu truy vấn và lấy thông tin chi tiết đơn hàng từ OrderReadModel.\nCác bước tạo hàm này tương tự như những phần trước.\nBước 1: Tạo hàm Lambda Chọn Author from scratch. Nhập tên hàm: OrderQueryHandler. Chọn Runtime: Python 3.12. Chọn Architecture: x86_64. Chọn Use an existing role và chọn EventSourcingLambdaRole. Nhấn Create function.\nBước 2: Triển khai mã hàm Thay thế mã mặc định bằng đoạn mã sau: import json import boto3 from boto3.dynamodb.conditions import Key from decimal import Decimal # Initialize DynamoDB dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) order_table = dynamodb.Table(\u0026#39;OrderReadModel\u0026#39;) customer_table = dynamodb.Table(\u0026#39;CustomerReadModel\u0026#39;) menu_items_table = dynamodb.Table(\u0026#39;MenuItems\u0026#39;) class DecimalEncoder(json.JSONEncoder): def default(self, o): if isinstance(o, Decimal): return float(o) return super(DecimalEncoder, self).default(o) def lambda_handler(event, context): try: http_method = event[\u0026#39;httpMethod\u0026#39;] path = event[\u0026#39;path\u0026#39;] query_params = event.get(\u0026#39;queryStringParameters\u0026#39;) or {} print(f\u0026#34;Processing {http_method} {path}\u0026#34;) print(f\u0026#34;Query params: {query_params}\u0026#34;) if path == \u0026#39;/orders\u0026#39; and http_method == \u0026#39;GET\u0026#39;: return handle_get_orders(query_params) elif path.startswith(\u0026#39;/orders/\u0026#39;) and http_method == \u0026#39;GET\u0026#39;: order_id = path.split(\u0026#39;/\u0026#39;)[-1] return handle_get_order(order_id) elif path == \u0026#39;/menu\u0026#39; and http_method == \u0026#39;GET\u0026#39;: return handle_get_menu() elif path == \u0026#39;/customers\u0026#39; and http_method == \u0026#39;GET\u0026#39;: return handle_get_customers(query_params) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Endpoint not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;}) def handle_get_orders(query_params): try: # Get all orders (in production, you\u0026#39;d want pagination) response = order_table.scan( Limit=50 # Limit to 50 orders ) orders = response.get(\u0026#39;Items\u0026#39;, []) # Sort by createdAt descending orders.sort(key=lambda x: x.get(\u0026#39;createdAt\u0026#39;, \u0026#39;\u0026#39;), reverse=True) return build_response(200, { \u0026#39;orders\u0026#39;: orders, \u0026#39;count\u0026#39;: len(orders) }) except Exception as e: print(f\u0026#34;Error getting orders: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get orders\u0026#39;}) def handle_get_order(order_id): try: response = order_table.get_item(Key={\u0026#39;orderId\u0026#39;: order_id}) if \u0026#39;Item\u0026#39; in response: return build_response(200, response[\u0026#39;Item\u0026#39;]) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Order not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error getting order: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get order\u0026#39;}) def handle_get_menu(): try: response = menu_items_table.scan() items = response.get(\u0026#39;Items\u0026#39;, []) # Filter only available items available_items = [item for item in items if item.get(\u0026#39;available\u0026#39;, False)] return build_response(200, { \u0026#39;items\u0026#39;: available_items, \u0026#39;count\u0026#39;: len(available_items) }) except Exception as e: print(f\u0026#34;Error getting menu: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get menu\u0026#39;}) def handle_get_customers(query_params): try: response = customer_table.scan( Limit=50 # Limit to 50 customers ) customers = response.get(\u0026#39;Items\u0026#39;, []) return build_response(200, { \u0026#39;customers\u0026#39;: customers, \u0026#39;count\u0026#39;: len(customers) }) except Exception as e: print(f\u0026#34;Error getting customers: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get customers\u0026#39;}) def build_response(status_code, body): return { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, PUT, DELETE, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(body, cls=DecimalEncoder, default=str) } Nhấn Deploy để lưu mã hàm. ✅ Hàm Lambda OrderQueryHandler đã sẵn sàng để xử lý các yêu cầu truy vấn đơn hàng.\n"
},
{
	"uri": "/vi/3-eventstore/3.4-create-menuitems-table/",
	"title": "Tạo bảng MenuItems",
	"tags": [],
	"description": "",
	"content": "Bước 1: Tạo bảng mới Trong DynamoDB Console, nhấn Create table. Table name: MenuItems Partition key: itemId (String) Chọn Default settings. Nhấn Create table. ✅ Kết quả: Bảng MenuItems đã sẵn sàng để lưu trữ dữ liệu thực đơn.\n"
},
{
	"uri": "/vi/4-deploylambda/",
	"title": "Triển khai Lambda Functions",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ triển khai bốn Lambda function cốt lõi tạo thành xương sống cho hệ thống đặt hàng theo mô hình Event Sourcing.\nNội dung 4.1. Triển khai hàm OrderCommandHandler\n4.2. Triển khai hàm OrderEventProcessor\n4.3. Triển khai hàm OrderQueryHandler\n4.4. Triển khai hàm State Reconstruction Handler\n"
},
{
	"uri": "/vi/4-deploylambda/4.4.-implementfunctionstatereconstructionhandler/",
	"title": "Triển khai State Reconstruction Handler",
	"tags": [],
	"description": "",
	"content": "Cuối cùng, chúng ta sẽ triển khai hàm Lambda State Reconstruction Handler.\nHàm này sẽ khôi phục trạng thái hiện tại của một đơn hàng bằng cách phát lại các sự kiện từ Event Store, đảm bảo trạng thái hệ thống luôn nhất quán với chuỗi sự kiện đã xảy ra.\nCác bước tạo hàm tương tự như các Lambda function trước đó.\nBước 1: Tạo Lambda Function Chọn Author from scratch. Nhập tên hàm: StateReconstructionHandler. Chọn Runtime: Python 3.12. Chọn Architecture: x86_64. Chọn Use an existing role và chọn EventSourcingLambdaRole. Nhấn Create function. Bước 2: Viết mã cho hàm Thay thế mã mặc định bằng nội dung sau: import json import boto3 from boto3.dynamodb.conditions import Key from decimal import Decimal from datetime import datetime # Initialize DynamoDB dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) event_store_table = dynamodb.Table(\u0026#39;EventStore\u0026#39;) order_table = dynamodb.Table(\u0026#39;OrderReadModel\u0026#39;) class DecimalEncoder(json.JSONEncoder): def default(self, o): if isinstance(o, Decimal): return float(o) return super(DecimalEncoder, self).default(o) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34; State Reconstruction Handler - HTTP request: rebuild theo API path - EventBridge event: rebuild ngay cho order liên quan \u0026#34;\u0026#34;\u0026#34; try: print(\u0026#34;Received event:\u0026#34;, json.dumps(event)) http_method = None path = None body = {} # Trường hợp API Gateway REST API if \u0026#39;httpMethod\u0026#39; in event: http_method = event[\u0026#39;httpMethod\u0026#39;] path = event.get(\u0026#39;path\u0026#39;) body = json.loads(event.get(\u0026#39;body\u0026#39;) or \u0026#34;{}\u0026#34;) # Trường hợp API Gateway HTTP API (v2 payload) elif event.get(\u0026#39;requestContext\u0026#39;, {}).get(\u0026#39;http\u0026#39;, {}).get(\u0026#39;method\u0026#39;): http_method = event[\u0026#39;requestContext\u0026#39;][\u0026#39;http\u0026#39;][\u0026#39;method\u0026#39;] path = event.get(\u0026#39;rawPath\u0026#39;) body = json.loads(event.get(\u0026#39;body\u0026#39;) or \u0026#34;{}\u0026#34;) # Trường hợp EventBridge event elif event.get(\u0026#34;detail-type\u0026#34;) in [\u0026#34;OrderPlaced\u0026#34;, \u0026#34;OrderConfirmed\u0026#34;, \u0026#34;OrderCancelled\u0026#34;]: order_id = event.get(\u0026#34;detail\u0026#34;, {}).get(\u0026#34;orderId\u0026#34;) if not order_id: print(\u0026#34;No orderId in event, skipping reconstruction.\u0026#34;) return build_response(400, {\u0026#34;error\u0026#34;: \u0026#34;orderId not found in event\u0026#34;}) print(f\u0026#34;Rebuilding state for orderId from EventBridge: {order_id}\u0026#34;) events = get_events_for_order(order_id) if not events: return build_response(404, {\u0026#34;error\u0026#34;: f\u0026#34;No events found for order {order_id}\u0026#34;}) reconstructed_state = reconstruct_order_state(events) update_read_model(reconstructed_state) return build_response(200, { \u0026#34;message\u0026#34;: f\u0026#34;State rebuilt from EventBridge event for order {order_id}\u0026#34;, \u0026#34;orderId\u0026#34;: order_id, \u0026#34;eventsProcessed\u0026#34;: len(events), \u0026#34;reconstructedState\u0026#34;: reconstructed_state }) else: print(\u0026#34;Unknown event source, skipping.\u0026#34;) return build_response(200, {\u0026#34;message\u0026#34;: \u0026#34;Event ignored\u0026#34;}) # Xử lý HTTP request như cũ print(f\u0026#34;Processing {http_method} {path}\u0026#34;) if path == \u0026#39;/reconstruct/order\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_reconstruct_order(body) elif path == \u0026#39;/reconstruct/all\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_reconstruct_all_orders(body) elif path == \u0026#39;/reconstruct/validate\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_validate_reconstruction(body) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Endpoint not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;}) def handle_reconstruct_order(body): \u0026#34;\u0026#34;\u0026#34;Reconstruct a single order from events\u0026#34;\u0026#34;\u0026#34; order_id = body.get(\u0026#39;orderId\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;orderId is required\u0026#39;}) try: # Get all events for this order events = get_events_for_order(order_id) if not events: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;No events found for order\u0026#39;}) # Reconstruct state from events reconstructed_state = reconstruct_order_state(events) # Update read model update_read_model(reconstructed_state) return build_response(200, { \u0026#39;message\u0026#39;: \u0026#39;Order state reconstructed successfully\u0026#39;, \u0026#39;orderId\u0026#39;: order_id, \u0026#39;eventsProcessed\u0026#39;: len(events), \u0026#39;reconstructedState\u0026#39;: reconstructed_state }) except Exception as e: print(f\u0026#34;Error reconstructing order {order_id}: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to reconstruct order\u0026#39;}) def handle_reconstruct_all_orders(body): \u0026#34;\u0026#34;\u0026#34;Reconstruct all orders from events\u0026#34;\u0026#34;\u0026#34; max_orders = body.get(\u0026#39;maxOrders\u0026#39;, 100) # Limit for safety try: # Get all unique aggregate IDs from event store response = event_store_table.scan( ProjectionExpression=\u0026#39;aggregateId\u0026#39;, Limit=max_orders ) order_ids = list(set([item[\u0026#39;aggregateId\u0026#39;] for item in response.get(\u0026#39;Items\u0026#39;, [])])) reconstructed_orders = [] errors = [] for order_id in order_ids: try: events = get_events_for_order(order_id) if events: reconstructed_state = reconstruct_order_state(events) update_read_model(reconstructed_state) reconstructed_orders.append({ \u0026#39;orderId\u0026#39;: order_id, \u0026#39;eventsProcessed\u0026#39;: len(events) }) except Exception as e: errors.append({ \u0026#39;orderId\u0026#39;: order_id, \u0026#39;error\u0026#39;: str(e) }) return build_response(200, { \u0026#39;message\u0026#39;: f\u0026#39;Reconstructed {len(reconstructed_orders)} orders\u0026#39;, \u0026#39;reconstructedOrders\u0026#39;: reconstructed_orders, \u0026#39;errors\u0026#39;: errors }) except Exception as e: print(f\u0026#34;Error reconstructing all orders: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to reconstruct orders\u0026#39;}) def handle_validate_reconstruction(body): \u0026#34;\u0026#34;\u0026#34;Validate reconstruction by comparing with current read model\u0026#34;\u0026#34;\u0026#34; order_id = body.get(\u0026#39;orderId\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;orderId is required\u0026#39;}) try: # Get current read model state current_state = order_table.get_item(Key={\u0026#39;orderId\u0026#39;: order_id}).get(\u0026#39;Item\u0026#39;) # Get reconstructed state from events events = get_events_for_order(order_id) reconstructed_state = reconstruct_order_state(events) # Compare states validation_result = compare_states(current_state, reconstructed_state) return build_response(200, { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;isValid\u0026#39;: validation_result[\u0026#39;isValid\u0026#39;], \u0026#39;differences\u0026#39;: validation_result[\u0026#39;differences\u0026#39;], \u0026#39;currentState\u0026#39;: current_state, \u0026#39;reconstructedState\u0026#39;: reconstructed_state }) except Exception as e: print(f\u0026#34;Error validating reconstruction: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to validate reconstruction\u0026#39;}) def get_events_for_order(order_id): \u0026#34;\u0026#34;\u0026#34;Get all events for a specific order, sorted by timestamp\u0026#34;\u0026#34;\u0026#34; try: response = event_store_table.query( IndexName=\u0026#39;AggregateIndex\u0026#39;, # Assuming GSI on aggregateId KeyConditionExpression=Key(\u0026#39;aggregateId\u0026#39;).eq(order_id), ScanIndexForward=True # Sort by timestamp ascending ) events = response.get(\u0026#39;Items\u0026#39;, []) # Sort by timestamp to ensure correct order events.sort(key=lambda x: x.get(\u0026#39;timestamp\u0026#39;, \u0026#39;\u0026#39;)) return events except Exception as e: print(f\u0026#34;Error getting events for order {order_id}: {str(e)}\u0026#34;) # Fallback to scan if GSI doesn\u0026#39;t exist response = event_store_table.scan( FilterExpression=Key(\u0026#39;aggregateId\u0026#39;).eq(order_id) ) events = response.get(\u0026#39;Items\u0026#39;, []) events.sort(key=lambda x: x.get(\u0026#39;timestamp\u0026#39;, \u0026#39;\u0026#39;)) return events def reconstruct_order_state(events): \u0026#34;\u0026#34;\u0026#34;Reconstruct order state by replaying events\u0026#34;\u0026#34;\u0026#34; state = { \u0026#39;orderId\u0026#39;: None, \u0026#39;status\u0026#39;: None, \u0026#39;customerName\u0026#39;: None, \u0026#39;customerPhone\u0026#39;: None, \u0026#39;customerAddress\u0026#39;: None, \u0026#39;items\u0026#39;: [], \u0026#39;totalAmount\u0026#39;: Decimal(\u0026#39;0\u0026#39;), \u0026#39;createdAt\u0026#39;: None, \u0026#39;updatedAt\u0026#39;: None, \u0026#39;confirmedAt\u0026#39;: None, \u0026#39;cancelledAt\u0026#39;: None, \u0026#39;cancelReason\u0026#39;: None, \u0026#39;estimatedDelivery\u0026#39;: None, \u0026#39;eventHistory\u0026#39;: [] } for event in events: event_type = event.get(\u0026#39;eventType\u0026#39;) event_data = event.get(\u0026#39;eventData\u0026#39;, {}) timestamp = event.get(\u0026#39;timestamp\u0026#39;) # Track event history state[\u0026#39;eventHistory\u0026#39;].append({ \u0026#39;eventType\u0026#39;: event_type, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;eventId\u0026#39;: event.get(\u0026#39;eventId\u0026#39;) }) if event_type == \u0026#39;OrderPlaced\u0026#39;: state[\u0026#39;orderId\u0026#39;] = event_data.get(\u0026#39;orderId\u0026#39;) state[\u0026#39;customerName\u0026#39;] = event_data.get(\u0026#39;customerName\u0026#39;) state[\u0026#39;customerPhone\u0026#39;] = event_data.get(\u0026#39;customerPhone\u0026#39;) state[\u0026#39;customerAddress\u0026#39;] = event_data.get(\u0026#39;customerAddress\u0026#39;) state[\u0026#39;items\u0026#39;] = event_data.get(\u0026#39;items\u0026#39;, []) state[\u0026#39;totalAmount\u0026#39;] = Decimal(str(event_data.get(\u0026#39;totalAmount\u0026#39;, 0))) state[\u0026#39;status\u0026#39;] = \u0026#39;PLACED\u0026#39; state[\u0026#39;createdAt\u0026#39;] = timestamp state[\u0026#39;updatedAt\u0026#39;] = timestamp elif event_type == \u0026#39;OrderConfirmed\u0026#39;: state[\u0026#39;status\u0026#39;] = \u0026#39;CONFIRMED\u0026#39; state[\u0026#39;confirmedAt\u0026#39;] = event_data.get(\u0026#39;confirmedAt\u0026#39;) state[\u0026#39;estimatedDelivery\u0026#39;] = event_data.get(\u0026#39;estimatedDelivery\u0026#39;) state[\u0026#39;updatedAt\u0026#39;] = timestamp elif event_type == \u0026#39;OrderCancelled\u0026#39;: state[\u0026#39;status\u0026#39;] = \u0026#39;CANCELLED\u0026#39; state[\u0026#39;cancelledAt\u0026#39;] = event_data.get(\u0026#39;cancelledAt\u0026#39;) state[\u0026#39;cancelReason\u0026#39;] = event_data.get(\u0026#39;reason\u0026#39;) state[\u0026#39;updatedAt\u0026#39;] = timestamp # Add more event types as needed return state def update_read_model(state): \u0026#34;\u0026#34;\u0026#34;Update the read model with reconstructed state\u0026#34;\u0026#34;\u0026#34; try: # Remove event history for read model read_model_state = {k: v for k, v in state.items() if k != \u0026#39;eventHistory\u0026#39;} order_table.put_item(Item=read_model_state) print(f\u0026#34;Updated read model for order {state[\u0026#39;orderId\u0026#39;]}\u0026#34;) except Exception as e: print(f\u0026#34;Error updating read model: {str(e)}\u0026#34;) raise def compare_states(current_state, reconstructed_state): \u0026#34;\u0026#34;\u0026#34;Compare current read model state with reconstructed state\u0026#34;\u0026#34;\u0026#34; differences = [] if not current_state: return { \u0026#39;isValid\u0026#39;: False, \u0026#39;differences\u0026#39;: [\u0026#39;Current state not found in read model\u0026#39;] } # Remove event history from comparison reconstructed_compare = {k: v for k, v in reconstructed_state.items() if k != \u0026#39;eventHistory\u0026#39;} # Compare key fields compare_fields = [\u0026#39;orderId\u0026#39;, \u0026#39;status\u0026#39;, \u0026#39;customerName\u0026#39;, \u0026#39;customerPhone\u0026#39;, \u0026#39;totalAmount\u0026#39;, \u0026#39;createdAt\u0026#39;, \u0026#39;confirmedAt\u0026#39;, \u0026#39;cancelledAt\u0026#39;] for field in compare_fields: current_value = current_state.get(field) reconstructed_value = reconstructed_compare.get(field) # Handle Decimal comparison if isinstance(current_value, Decimal) and isinstance(reconstructed_value, Decimal): if current_value != reconstructed_value: differences.append(f\u0026#34;{field}: current={current_value}, reconstructed={reconstructed_value}\u0026#34;) elif str(current_value) != str(reconstructed_value): differences.append(f\u0026#34;{field}: current={current_value}, reconstructed={reconstructed_value}\u0026#34;) return { \u0026#39;isValid\u0026#39;: len(differences) == 0, \u0026#39;differences\u0026#39;: differences } def build_response(status_code, body): return { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, PUT, DELETE, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(body, cls=DecimalEncoder, default=str) } Nhấn Deploy để lưu mã hàm.\n✅ Hàm Lambda StateReconstructionHandler hiện đã sẵn sàng để khôi phục trạng thái đơn hàng bằng cách phát lại các sự kiện.\n"
},
{
	"uri": "/vi/3-eventstore/3.5-seed-data-menuitems/",
	"title": "Khởi tạo dữ liệu cho MenuItems",
	"tags": [],
	"description": "",
	"content": "Bước 1: Mở bảng MenuItems Vào bảng MenuItems trong DynamoDB Console.\nNhấp Explore table items.\nNhấp Create item.\nBước 2: Thêm món ăn Bây giờ, chúng ta sẽ thêm dữ liệu mẫu vào bảng MenuItems. Mỗi món ăn sẽ được thêm thủ công qua DynamoDB Console.\nPhương pháp này chỉ dùng để nhanh chóng thêm dữ liệu mẫu phục vụ mục đích demo.\nTrên trang Create item, nhấp JSON view ở góc trên bên phải để chuyển từ Form view sang chế độ JSON.\nSao chép và dán JSON của từng món ăn bên dưới vào trình soạn thảo, sau đó nhấn Create item để lưu. Lặp lại quy trình cho cả ba món. Item 1 - Pizza:\n{ \u0026#34;itemId\u0026#34;: \u0026#34;pizza-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Pizza Margherita\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Classic pizza with tomato sauce, mozzarella, and basil\u0026#34;, \u0026#34;price\u0026#34;: 12.99, \u0026#34;category\u0026#34;: \u0026#34;Pizza\u0026#34;, \u0026#34;available\u0026#34;: true, \u0026#34;image\u0026#34;: \u0026#34;https://digiticket.vn/blog/wp-content/uploads/2021/09/pizza-hut-5.jpg\u0026#34; } Item 2 - Burger:\n{ \u0026#34;itemId\u0026#34;: \u0026#34;burger-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Beef Burger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Juicy beef patty with lettuce, tomato, and cheese\u0026#34;, \u0026#34;price\u0026#34;: 8.99, \u0026#34;category\u0026#34;: \u0026#34;Burger\u0026#34;, \u0026#34;available\u0026#34;: true, \u0026#34;image\u0026#34;: \u0026#34;https://i-kinhdoanh.vnecdn.net/2022/08/25/image001-9906-1661419989.jpg\u0026#34; } Item 3 - Drink:\n{ \u0026#34;itemId\u0026#34;: \u0026#34;drink-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Coca Cola\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Classic cola drink\u0026#34;, \u0026#34;price\u0026#34;: 2.99, \u0026#34;category\u0026#34;: \u0026#34;Drink\u0026#34;, \u0026#34;available\u0026#34;: true, \u0026#34;image\u0026#34;: \u0026#34;https://assets.xoimoc.com/responsive-images/md/products/cocacola.png\u0026#34; } Chế độ JSON view giúp nhập liệu hàng loạt nhanh hơn, trong khi Form view lại hữu ích khi muốn kiểm tra trực quan giá trị và kiểu dữ liệu.\nSau khi đã tạo xong cả ba món, quay lại Explore table items. Lúc này bạn sẽ thấy bảng đã được điền dữ liệu mẫu: Muốn tăng tốc khi thêm nhiều dữ liệu?\nThay vì tạo từng bản ghi thủ công trong console, bạn có thể dùng BatchWriteItem API hoặc AWS CLI để chèn nhiều mục cùng lúc.\n"
},
{
	"uri": "/vi/5-setupeventbridge/",
	"title": "Triển khai Pipeline EventBridge",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ thiết lập hạ tầng EventBridge để hỗ trợ kiến trúc Event Sourcing cho hệ thống đặt đồ ăn nhanh.\nĐiều này bao gồm việc tạo một Custom Event Bus chuyên dụng để thu thập và định tuyến tất cả các sự kiện domain liên quan đến đơn hàng,\nnhư OrderPlaced, OrderConfirmed, và OrderCancelled.\nBằng cách định nghĩa các Event Rule chính xác, chúng ta đảm bảo mỗi sự kiện sẽ được gửi đến đúng hàm Lambda\nchịu trách nhiệm xử lý và cập nhật trạng thái hệ thống một cách bất đồng bộ.\nNgoài ra, chúng ta cũng sẽ tạo một SNS Topic để phát thông báo được kích hoạt từ các sự kiện này.\nPipeline EventBridge là một thành phần quan trọng trong thiết kế Event Sourcing, giúp hệ thống xử lý sự kiện một cách đáng tin cậy, tách biệt\nvà thời gian thực. Điều này cho phép hệ thống tái tạo trạng thái từ các sự kiện và phản hồi nhanh chóng với mọi thay đổi.\nNội dung: 5.1 Tạo Custom Event Bus 5.1.1 Cấu hình EventBridge Rules 5.2 Tạo SNS Topic cho thông báo "
},
{
	"uri": "/vi/6-configapigateway/",
	"title": "Cấu hình API Gateway",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ cấu hình Amazon API Gateway để đóng vai trò \u0026ldquo;cổng vào\u0026rdquo; cho hệ thống đặt đồ ăn nhanh.\nAPI Gateway sẽ hoạt động như một giao diện RESTful mà client sử dụng để tương tác với kiến trúc Event Sourcing, cung cấp quyền truy cập an toàn và khả năng mở rộng tới các Lambda function.\nChúng ta sẽ tạo mới một API Gateway để cung cấp các endpoint phục vụ quản lý đơn hàng, chẳng hạn như tạo đơn hàng, lấy trạng thái đơn, và xử lý yêu cầu từ khách hàng.\nAPI Gateway sẽ tích hợp liền mạch với các Lambda function, từ đó gửi sự kiện vào pipeline EventBridge.\nNgoài ra, chúng ta sẽ bật Cross-Origin Resource Sharing (CORS) để cho phép các ứng dụng web từ domain khác tương tác với API, đảm bảo khả năng tương thích với các chuẩn phát triển web hiện đại.\nCuối cùng, chúng ta sẽ triển khai API để có thể truy cập từ các client bên ngoài.\nCấu hình API Gateway này rất quan trọng để cung cấp một giao diện RESTful rõ ràng cho kiến trúc hướng sự kiện, giúp client kích hoạt các domain event trong khi vẫn duy trì nguyên tắc tách biệt giữa tầng trình bày và phần triển khai Event Sourcing.\nNội dung: 6.1 Tạo API Gateway mới 6.2 Bật CORS 6.3 Triển khai API "
},
{
	"uri": "/vi/7-deployfrontend/",
	"title": "Triển khai ứng dụng Frontend",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ chuẩn bị và triển khai ứng dụng frontend cho Hệ thống Đặt hàng FastFood. Các bước bao gồm:\nCấu hình các biến môi trường cần thiết. Xây dựng mã nguồn frontend. Triển khai các file đã build lên bucket S3 để lưu trữ tĩnh. Thiết lập Amazon CloudFront làm CDN để phân phối tài nguyên frontend một cách hiệu quả và bảo mật. Các phần tiếp theo sẽ hướng dẫn bạn từng bước, từ thiết lập môi trường đến triển khai và cấu hình CDN.\nNội dung: 7.1 Tạo bucket S3 7.2 Tải frontend lên S3 7.3 Tạo CloudFront Distribution và áp dụng cho website "
},
{
	"uri": "/vi/8-testing/",
	"title": "Kiểm thử &amp; Giám sát",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ kiểm tra tính năng của Hệ thống Đặt hàng FastFood và triển khai các giải pháp giám sát nhằm đảm bảo hiệu suất tối ưu. Các nội dung bao gồm:\nThực hiện kiểm thử toàn diện cả phần frontend và backend để xác minh chức năng hệ thống. Thiết lập các giải pháp giám sát và ghi log để theo dõi hiệu suất ứng dụng, tương tác người dùng và sức khỏe hệ thống. Cấu hình cảnh báo và bảng điều khiển (dashboard) để chủ động phát hiện và xử lý sự cố. Áp dụng các phương pháp thực hành tốt nhất cho khả năng quan sát ứng dụng trong môi trường điện toán đám mây. Các phần dưới đây sẽ hướng dẫn bạn quy trình kiểm thử và thiết lập giám sát để đảm bảo Hệ thống Đặt hàng FastFood hoạt động ổn định và hiệu quả.\nNội dung: 8.1 Kiểm thử ứng dụng 8.2 Giám sát "
},
{
	"uri": "/vi/9-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ thực hiện các bước sau để xóa các tài nguyên đã tạo trong workshop này.\nXóa nhóm Log CloudWatch Truy cập bảng điều khiển dịch vụ CloudWatch Nhấp vào Logs ở thanh bên trái.\nNhấp vào Log groups.\nChọn các nhóm log mà chúng ta đã tạo cho bài lab này:\n/aws/lambda/OrderCommandHandler /aws/lambda/OrderEventProcessor /aws/lambda/OrderQueryHandler /aws/lambda/StateReconstructionHandler Nhấp Actions.\nNhấp Delete log group(s).\nTrong hộp thoại xác nhận, nhấp Delete để xác nhận xóa.\nXóa API Gateway Truy cập bảng điều khiển dịch vụ API Gateway\nNhấp APIs ở thanh bên trái. Chọn API FastFoodOrderAPI. Nhấp Actions. Nhấp Delete. Gõ confirm vào ô xác nhận. Nhấp Delete để xóa API vĩnh viễn. Xóa CloudFront Distribution Truy cập bảng điều khiển dịch vụ CloudFront\nNhấp Distributions ở thanh bên trái. Chọn distribution mà chúng ta đã tạo (ID: E2GXEUIB6RGU9). Nhấp Disable. Chờ trạng thái distribution chuyển thành Disabled. Chọn distribution đã Disabled. Nhấp Delete. Nhấp Delete để xác nhận xóa. Xóa Bucket và các đối tượng trong S3 Truy cập bảng điều khiển dịch vụ S3\nNhấp vào bucket S3 có tên event-sourcing-fastfood-frontend. Nhấp Empty. Gõ permanently delete vào ô xác nhận. Nhấp Empty để xóa tất cả đối tượng trong bucket. Nhấp Exit. Sau khi đã xóa hết đối tượng trong bucket:\nChọn bucket event-sourcing-fastfood-frontend. Nhấp Delete. Gõ tên bucket event-sourcing-fastfood-frontend vào ô xác nhận. Nhấp Delete bucket để xóa bucket vĩnh viễn. Xóa bảng DynamoDB Truy cập bảng điều khiển dịch vụ DynamoDB\nNhấp Tables ở thanh bên trái.\nChọn tất cả bảng mà chúng ta đã tạo:\nCustomerReadModel EventStore MenuItems OrderReadModel Nhấp Actions.\nNhấp Delete.\nTrong hộp thoại xác nhận, gõ confirm vào ô nhập.\nNhấp Delete để xóa các bảng vĩnh viễn.\nXóa topic SNS Truy cập bảng điều khiển dịch vụ SNS\nNhấp Topics ở thanh bên trái. Chọn topic OrderNotifications. Nhấp Delete. Trong hộp thoại xác nhận, gõ delete me vào ô nhập. Nhấp Delete để xác nhận xóa. Xóa tài nguyên EventBridge Truy cập bảng điều khiển dịch vụ EventBridge\nNhấp Event buses ở thanh bên trái. Chọn event bus tùy chỉnh FastFoodOrderBus. Nhấp Delete. Trong hộp thoại xác nhận, gõ delete vào ô nhập. Nhấp Delete để xác nhận xóa. Vẫn trong bảng điều khiển EventBridge:\nNhấp Rules ở thanh bên trái.\nChọn các rule chúng ta đã tạo:\nOrderEventProcessingRule StateReconstructionRule Nhấp Delete.\nGõ delete vào ô xác nhận.\nNhấp Delete để xác nhận xóa.\nXóa các hàm Lambda Truy cập bảng điều khiển dịch vụ Lambda\nNhấp Functions ở thanh bên trái.\nChọn tất cả các hàm chúng ta đã tạo:\nOrderCommandHandler OrderEventProcessor StateReconstructionHandler OrderQueryHandler Nhấp Actions.\nNhấp Delete.\nTrong hộp thoại xác nhận, gõ confirm vào ô nhập.\nNhấp Delete để xóa các hàm vĩnh viễn.\nXóa IAM Role Truy cập bảng điều khiển dịch vụ IAM\nNhấp Roles ở thanh bên trái. Tìm kiếm role EventSourcingLambdaRole. Nhấp để chọn role. Nhấp Delete. Nhập tên role EventSourcingLambdaRole vào ô xác nhận. Nhấp Delete để xác nhận xóa. "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]