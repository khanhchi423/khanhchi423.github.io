[
{
	"uri": "//localhost:1313/3-eventstore/3.1-create-eventstore-table/",
	"title": "Create EventStore Table",
	"tags": [],
	"description": "",
	"content": "Step 1: Open DynamoDB Console In the AWS Management Console, search for DynamoDB. Click DynamoDB to open the service. Step 2: Create Table Click Create table. Enter Table name: EventStore Enter Partition key: aggregateId (String) Enter Sort key: eventId (String) Select Default settings. Click Create table. ✅ Result: The EventStore table will be created with aggregateId and eventId as keys.\nStep 3: Create Global Secondary Index After the EventStore table is created, you need to add a Global Secondary Index for efficient querying.\nIn the EventStore table, click on the Indexes tab.\nClick Create index button. Configure the Global Secondary Index:\nPartition key: aggregateId (String) Sort key: timestamp (String) Index name: AggregateIndex Data type: Keep both as String Capacity mode: On-demand (default) Leave other settings as default and click Create index. ✅ Result: The EventStore table is now ready with:\nPrimary key: aggregateId (Partition) + eventId (Sort) Global Secondary Index: AggregateIndex with aggregateId (Partition) + timestamp (Sort) On-demand capacity mode for automatic scaling\nThis setup allows efficient querying of events both by individual event ID and by aggregate with time-based ordering.\n"
},
{
	"uri": "//localhost:1313/6-configapigateway/6.1-create-new-api-gateway/",
	"title": "Create New API Gateway",
	"tags": [],
	"description": "",
	"content": "In this section, we will create a new REST API using Amazon API Gateway to serve as the HTTP interface for our fast food ordering system. This API will provide endpoints for order management operations and integrate with our Lambda functions that implement the Event Sourcing architecture.\nStep 1: Open Amazon API Gateway Console In the AWS Management Console, search for API Gateway. Click API Gateway to open the service. Step 2: Create New REST API Click Create API button. Choose REST API and click Build. Configure API settings:\nChoose the protocol: REST Create new API: New API (selected by default) API name: FastFoodOrderAPI Description: API for FastFood Order System API endpoint type: Regional Click Create API. ✅ Result: The FastFoodOrderAPI REST API is successfully created and ready for resource and method configuration.\nStep 3: Create Resource /orders In the newly created API → Create Resource Configure resource:\nResource Name: orders Resource Path: /orders Enable API Gateway CORS: Check this option Click Create Resource Step 4: Create POST method for /orders Select the /orders resource\nClick Actions → Create Method Select POST from dropdown → Click ✓\nConfigure method:\nIntegration type: Lambda Function Lambda Region: Select your region Lambda Function: OrderCommandHandler Use Default Timeout: Check this option Click Save\nClick OK to allow API Gateway to invoke Lambda Step 5: Create GET method for /orders Select the /orders resource\nClick Actions → Create Method\nSelect GET → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: OrderQueryHandler Click Save → OK\nStep 6: Create Resource /orders/{id} Select the /orders resource Click Actions → Create Resource Configure: Resource Name: {id} Resource Path: /{id} Enable API Gateway CORS: Check this option Click Create Resource Step 7: Create GET method for /orders/{id} Select the /{id} resource\nClick Actions → Create Method\nSelect GET → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: OrderQueryHandler Click Save → OK\nStep 8: Create Resource /orders/confirm Select the /orders resource\nClick Actions → Create Resource\nConfigure:\nResource Name: confirm Resource Path: /confirm Enable API Gateway CORS: Check this option Click Create Resource\nStep 9: Create POST method for /orders/confirm Select the /confirm resource\nClick Actions → Create Method\nSelect POST → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: OrderCommandHandler\nClick Save → OK\nStep 10: Create Resource /orders/cancel Select the /orders resource\nClick Actions → Create Resource\nConfigure:\nResource Name: cancel Resource Path: /cancel Enable API Gateway CORS: Check this option Click Create Resource\nStep 11: Create POST method for /orders/cancel Select the /cancel resource\nClick Actions → Create Method\nSelect POST → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: OrderCommandHandler Click Save → OK\nStep 12: Create Resource /menu Select the root resource /\nClick Actions → Create Resource\nConfigure:\nResource Name: menu Resource Path: /menu Enable API Gateway CORS: Check this option Click Create Resource\nStep 13: Create GET method for /menu Select the /menu resource\nClick Actions → Create Method\nSelect GET → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: OrderQueryHandler Click Save → OK\nStep 14: Create Resource /customers Select the root resource /\nClick Actions → Create Resource\nConfigure:\nResource Name: customers Resource Path: /customers Enable API Gateway CORS: Check this option Click Create Resource\nStep 15: Create GET method for /customers Select the /customers resource\nClick Actions → Create Method\nSelect GET → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: OrderQueryHandler Click Save → OK\nStep 16: Create Resource /reconstruct Select the root resource /\nClick Actions → Create Resource\nConfigure:\nResource Name: reconstruct Resource Path: /reconstruct Enable API Gateway CORS: Check this option Click Create Resource\nStep 17: Create Resource /reconstruct/order Select the /reconstruct resource\nClick Actions → Create Resource\nConfigure:\nResource Name: order Resource Path: /order Enable API Gateway CORS: Check this option Click Create Resource\nStep 18: Create POST method for /reconstruct/order Select the /reconstruct/order resource\nClick Actions → Create Method\nSelect POST → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: StateReconstructionHandler Click Save → OK\nStep 19: Create Resource /reconstruct/all Select the /reconstruct resource\nClick Actions → Create Resource\nConfigure:\nResource Name: all Resource Path: /all Enable API Gateway CORS: Check this option Click Create Resource\nStep 20: Create POST method for /reconstruct/all Select the /reconstruct/all resource\nClick Actions → Create Method\nSelect POST → Click ✓\nConfigure:\nIntegration type: Lambda Function Lambda Function: StateReconstructionHandler Click Save → OK\nStep 19: Create Resource /reconstruct/validate Select the /reconstruct resource\nClick Actions → Create Resource\nConfigure:\nResource Name: validate Resource Path: /validate Enable API Gateway CORS: Check this option Click Create Resource\n"
},
{
	"uri": "//localhost:1313/7-deployfrontend/7.1-create-s3-bucket/",
	"title": "Create S3 bucket",
	"tags": [],
	"description": "",
	"content": "Step 1: Access the S3 Console In the AWS Management Console, search for S3. Click S3 to open the service. Step 2: Create a New Bucket Click Create bucket. Enter a unique bucket name, for example:\nevent-sourcing-fastfood-frontend\nSelect the region closest to your users (e.g., ap-southeast-1).\nIn Block Public Access settings for this bucket, uncheck all boxes to allow public access for static website hosting. Click Create bucket.\nOpen the bucket you just created.\nGo to the Properties tab. Scroll down to Static website hosting and click Edit. Select Enable.\nSet the Index document to index.html.\nClick Save changes. Step 3: Configure Bucket Policy for Public Access Still inside your bucket, navigate to the Permissions tab.\nScroll down to Bucket policy and click Edit. Add the following bucket policy to allow public read access to your static website files:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::event-sourcing-fastfood-frontend/*\u0026#34; } ] } Replace event-sourcing-fastfood-frontend with your actual bucket name. Click Save changes.\n"
},
{
	"uri": "//localhost:1313/5-setupeventbridge/5.1-customeventbus/",
	"title": "Custom Event Bus Setup for Event Sourcing Workflow",
	"tags": [],
	"description": "",
	"content": "Step 1 Open Amazon EventBridge Console In the AWS Management Console, search for EventBridge. Click Amazon EventBridge to open the service. Step 2: Create Event Bus Click Event buses in the left navigation panel. Click Create event bus. Enter Name: FastFoodOrderBus Enter Description: Custom event bus for fastfood order events Keep default settings for Encryption. Click Create event bus. ✅ Result: The FastFoodOrderBus custom event bus is successfully created and ready to receive order events. "
},
{
	"uri": "//localhost:1313/",
	"title": "DEPLOYING A SERVERLESS ORDERING SYSTEM WITH EVENT SOURCING ON AWS",
	"tags": [],
	"description": "",
	"content": "DEPLOYING A SERVERLESS ORDERING SYSTEM WITH EVENT SOURCING ON AWS Overall In this workshop, you\u0026rsquo;ll learn the fundamentals and practical implementation of Event Sourcing Pattern using AWS Serverless services. Build a complete fastfood ordering system with instant event processing, state reconstruction, and comprehensive monitoring.\nContent Introduction Preparation Create Event Store (DynamoDB) Deploy Lambda Functions Setup EventBridge Pipeline Config API Gateway Deploy Frontend Application Testing \u0026amp; Monitoring Clean up resources "
},
{
	"uri": "//localhost:1313/4-deploylambda/4.1-implementfunctionordercommandhandler/",
	"title": "Implement OrderCommandHandler ",
	"tags": [],
	"description": "",
	"content": "In this section, we will implement the OrderCommandHandler Lambda function that processes order-related commands from our fast food ordering system. This function will handle order placement, confirmation, and cancellation operations.\nStep 1: Open Lambda Console In the AWS Management Console, search for Lambda. Click Lambda to open the service. Step 2: Create Lambda Function Click Create function. Select Author from scratch.\nEnter Function name: OrderCommandHandler.\nSelect Runtime: Python 3.12.\nSelect Architecture: x86_64.\nExpand Change default execution role.\nSelect Use an existing role.\nChoose EventSourcingLambdaRole from the dropdown.\nClick Create function. Step 3: Implement Function Code In the Code source section of the OrderCommandHandler function, replace the default code with the following: import json import boto3 import uuid from datetime import datetime, timedelta from decimal import Decimal # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) eventbridge = boto3.client(\u0026#39;events\u0026#39;) # DynamoDB tables event_store_table = dynamodb.Table(\u0026#39;EventStore\u0026#39;) menu_items_table = dynamodb.Table(\u0026#39;MenuItems\u0026#39;) def lambda_handler(event, context): try: # Parse request http_method = event[\u0026#39;httpMethod\u0026#39;] path = event[\u0026#39;path\u0026#39;] body = json.loads(event[\u0026#39;body\u0026#39;]) if event.get(\u0026#39;body\u0026#39;) else {} print(f\u0026#34;Processing {http_method} {path}\u0026#34;) print(f\u0026#34;Body: {body}\u0026#34;) if path == \u0026#39;/orders\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_place_order(body) elif path == \u0026#39;/orders/confirm\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_confirm_order(body) elif path == \u0026#39;/orders/cancel\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_cancel_order(body) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Endpoint not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;}) def handle_place_order(order_data): # Validate order data required_fields = [\u0026#39;customerName\u0026#39;, \u0026#39;customerPhone\u0026#39;, \u0026#39;customerAddress\u0026#39;, \u0026#39;items\u0026#39;] if not all(field in order_data for field in required_fields): return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Missing required fields\u0026#39;}) # Validate items if not order_data[\u0026#39;items\u0026#39;] or len(order_data[\u0026#39;items\u0026#39;]) == 0: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Order must contain at least one item\u0026#39;}) # Generate order ID order_id = str(uuid.uuid4()) # Calculate total amount total_amount = Decimal(\u0026#39;0\u0026#39;) validated_items = [] for item in order_data[\u0026#39;items\u0026#39;]: if \u0026#39;itemId\u0026#39; not in item or \u0026#39;quantity\u0026#39; not in item: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Each item must have itemId and quantity\u0026#39;}) # Get item price from menu try: menu_item = menu_items_table.get_item(Key={\u0026#39;itemId\u0026#39;: item[\u0026#39;itemId\u0026#39;]}) if \u0026#39;Item\u0026#39; not in menu_item: return build_response(400, {\u0026#39;error\u0026#39;: f\u0026#39;Item {item[\u0026#34;itemId\u0026#34;]} not found\u0026#39;}) menu_item_data = menu_item[\u0026#39;Item\u0026#39;] if not menu_item_data.get(\u0026#39;available\u0026#39;, False): return build_response(400, {\u0026#39;error\u0026#39;: f\u0026#39;Item {item[\u0026#34;itemId\u0026#34;]} is not available\u0026#39;}) item_price = Decimal(str(menu_item_data[\u0026#39;price\u0026#39;])) quantity = int(item[\u0026#39;quantity\u0026#39;]) item_total = item_price * quantity total_amount += item_total validated_items.append({ \u0026#39;itemId\u0026#39;: item[\u0026#39;itemId\u0026#39;], \u0026#39;name\u0026#39;: menu_item_data[\u0026#39;name\u0026#39;], \u0026#39;price\u0026#39;: item_price, # Keep as Decimal for DynamoDB \u0026#39;quantity\u0026#39;: quantity, \u0026#39;image\u0026#39;: menu_item_data.get(\u0026#39;image\u0026#39;, \u0026#39;\u0026#39;), \u0026#39;total\u0026#39;: item_total # Keep as Decimal for DynamoDB }) except Exception as e: print(f\u0026#34;Error processing item {item[\u0026#39;itemId\u0026#39;]}: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: f\u0026#39;Error processing item {item[\u0026#34;itemId\u0026#34;]}\u0026#39;}) # Create OrderPlaced event event_id = str(uuid.uuid4()) timestamp = datetime.utcnow().isoformat() event_data = { \u0026#39;eventId\u0026#39;: event_id, \u0026#39;aggregateId\u0026#39;: order_id, \u0026#39;eventType\u0026#39;: \u0026#39;OrderPlaced\u0026#39;, \u0026#39;eventData\u0026#39;: { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;customerName\u0026#39;: order_data[\u0026#39;customerName\u0026#39;], \u0026#39;customerPhone\u0026#39;: order_data[\u0026#39;customerPhone\u0026#39;], \u0026#39;customerAddress\u0026#39;: order_data[\u0026#39;customerAddress\u0026#39;], \u0026#39;items\u0026#39;: validated_items, \u0026#39;totalAmount\u0026#39;: total_amount, # Keep as Decimal for DynamoDB \u0026#39;status\u0026#39;: \u0026#39;PLACED\u0026#39;, \u0026#39;timestamp\u0026#39;: timestamp }, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;version\u0026#39;: 1 } try: # Store event in Event Store event_store_table.put_item(Item=event_data) print(f\u0026#34;Event stored successfully in EventStore\u0026#34;) # Publish event to EventBridge (convert Decimals to float for JSON serialization) publish_event_to_bridge(event_data) print(f\u0026#34;Event published to EventBridge successfully\u0026#34;) return build_response(201, { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;message\u0026#39;: \u0026#39;Order placed successfully\u0026#39;, \u0026#39;totalAmount\u0026#39;: float(total_amount), # Convert to float for JSON response \u0026#39;items\u0026#39;: convert_decimals_to_float(validated_items), # Convert for JSON response \u0026#39;status\u0026#39;: \u0026#39;PLACED\u0026#39; }) except Exception as e: print(f\u0026#34;Error storing event: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to process order\u0026#39;}) def handle_confirm_order(confirm_data): order_id = confirm_data.get(\u0026#39;orderId\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Order ID required\u0026#39;}) # Calculate estimated delivery time (30 minutes from now) estimated_delivery = (datetime.utcnow() + timedelta(minutes=30)).isoformat() # Create OrderConfirmed event event_id = str(uuid.uuid4()) timestamp = datetime.utcnow().isoformat() event_data = { \u0026#39;eventId\u0026#39;: event_id, \u0026#39;aggregateId\u0026#39;: order_id, \u0026#39;eventType\u0026#39;: \u0026#39;OrderConfirmed\u0026#39;, \u0026#39;eventData\u0026#39;: { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;confirmedAt\u0026#39;: timestamp, \u0026#39;estimatedDelivery\u0026#39;: estimated_delivery, \u0026#39;status\u0026#39;: \u0026#39;CONFIRMED\u0026#39; }, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;version\u0026#39;: 1 } try: # Store event event_store_table.put_item(Item=event_data) # Publish event publish_event_to_bridge(event_data) return build_response(200, { \u0026#39;message\u0026#39;: \u0026#39;Order confirmed successfully\u0026#39;, \u0026#39;estimatedDelivery\u0026#39;: estimated_delivery }) except Exception as e: print(f\u0026#34;Error confirming order: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to confirm order\u0026#39;}) def handle_cancel_order(cancel_data): order_id = cancel_data.get(\u0026#39;orderId\u0026#39;) reason = cancel_data.get(\u0026#39;reason\u0026#39;, \u0026#39;Customer request\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Order ID required\u0026#39;}) # Create OrderCancelled event event_id = str(uuid.uuid4()) timestamp = datetime.utcnow().isoformat() event_data = { \u0026#39;eventId\u0026#39;: event_id, \u0026#39;aggregateId\u0026#39;: order_id, \u0026#39;eventType\u0026#39;: \u0026#39;OrderCancelled\u0026#39;, \u0026#39;eventData\u0026#39;: { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;cancelledAt\u0026#39;: timestamp, \u0026#39;reason\u0026#39;: reason, \u0026#39;status\u0026#39;: \u0026#39;CANCELLED\u0026#39; }, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;version\u0026#39;: 1 } try: # Store event event_store_table.put_item(Item=event_data) # Publish event publish_event_to_bridge(event_data) return build_response(200, { \u0026#39;message\u0026#39;: \u0026#39;Order cancelled successfully\u0026#39;, \u0026#39;reason\u0026#39;: reason }) except Exception as e: print(f\u0026#34;Error cancelling order: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to cancel order\u0026#39;}) def publish_event_to_bridge(event_data): try: # Convert Decimal values to float for JSON serialization event_data_for_bridge = convert_decimals_to_float(event_data[\u0026#39;eventData\u0026#39;]) print(f\u0026#34;Publishing event to EventBridge: {event_data[\u0026#39;eventType\u0026#39;]}\u0026#34;) print(f\u0026#34;Event data: {event_data_for_bridge}\u0026#34;) response = eventbridge.put_events( Entries=[ { \u0026#39;Source\u0026#39;: \u0026#39;fastfood.orders\u0026#39;, \u0026#39;DetailType\u0026#39;: event_data[\u0026#39;eventType\u0026#39;], \u0026#39;Detail\u0026#39;: json.dumps(event_data_for_bridge, default=str), \u0026#39;EventBusName\u0026#39;: \u0026#39;FastFoodOrderBus\u0026#39; } ] ) print(f\u0026#34;EventBridge response: {response}\u0026#34;) # Check if there were any failures if response.get(\u0026#39;FailedEntryCount\u0026#39;, 0) \u0026gt; 0: print(f\u0026#34;Failed to publish some events: {response.get(\u0026#39;Entries\u0026#39;, [])}\u0026#34;) raise Exception(\u0026#34;Failed to publish event to EventBridge\u0026#34;) except Exception as e: print(f\u0026#34;Error publishing event to EventBridge: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def convert_decimals_to_float(obj): \u0026#34;\u0026#34;\u0026#34; Recursively convert Decimal objects to float for JSON serialization \u0026#34;\u0026#34;\u0026#34; if isinstance(obj, list): return [convert_decimals_to_float(item) for item in obj] elif isinstance(obj, dict): return {key: convert_decimals_to_float(value) for key, value in obj.items()} elif isinstance(obj, Decimal): return float(obj) else: return obj def build_response(status_code, body): return { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, PUT, DELETE, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(body, default=str) } Click Deploy to save the function code. ✅ Result: The OrderCommandHandler Lambda function is successfully created and ready to process order commands.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.1-install-nodejs/",
	"title": "Install Nodejs &amp; npm",
	"tags": [],
	"description": "",
	"content": "Download nodejs \u0026amp; npm Visit the Node.js homepage and select the LTS version to download, compatible with your operating system (Windows, macOS, Linux). Run the downloaded installer file and follow the instructions to install Node.js\nAfter the installation is complete, open the Terminal and check the Node.js and npm versions using the following command:\nnode -v npm -v If this output appears, it means you have successfully installed it. "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "🎯 Event Sourcing Pattern is an architectural pattern within distributed system design that stores all changes to application state as a sequence of immutable events, rather than just maintaining current state. This approach provides complete auditability and traceability without traditional database updates or deletions. Event Sourcing also makes it easy to comply with regulatory requirements that demand full audit trails, strict data governance practices, and completely traceable business operations with detailed event logs, while still providing developers with powerful state reconstruction capabilities and real-time event processing for modern applications.\nCore Principles:\nImmutable Events: Each change is recorded as an unchangeable event Append-Only Storage: Events are only added, never updated or deleted State Reconstruction: Current state is calculated by replaying events Complete History: Maintains the entire history of system changes This approach provides complete auditability, historical traceability, and regulatory compliance that demands detailed audit trails, while offering flexible state reconstruction capabilities and real-time event processing for modern applications. 🔀 CQRS (Command Query Responsibility Segregation) Event Sourcing is commonly combined with CQRS Pattern for performance optimization:\nWhat is CQRS?\nCommand: Handles write operations (Create, Update, Delete) Query: Handles read operations (Read) Responsibility Segregation: Separates read and write responsibilities Benefits of CQRS + Event Sourcing:\nIndependent Read/Write Optimization: Read models and Write models can be optimized separately Scalability: Scale read and write operations independently Flexibility: Multiple different read models from the same event store Performance: Queries optimized for specific use cases Event Sourcing vs CRUD Comparison Aspect CRUD Event Sourcing Data Storage Stores current state Stores event sequence Data Loss Loses history on update Maintains complete history Audit Trail Requires separate implementation Built-in automatically Complexity Simple More complex Read Performance Fast for simple queries Highly optimized with read models Write Performance Potential bottlenecks Append-only, faster Scalability Limited High, independent scaling Debugging Difficult to trace history Easy to debug and replay Consistency ACID transactions Eventual consistency The overall architecture of the system we will build: ☁️ Architecture Components Description 🔄 Main Workflow: Client Request\nClient sends requests through CloudFront (global CDN) CloudFront caches static content and routes dynamic requests API Gateway\nReceives requests from CloudFront Handles authentication, rate limiting, request validation Routes requests to appropriate Lambda functions Command Handler (Lambda)\nProcesses business logic for write operations Validates commands and generates events Appends events to EventStore (DynamoDB) Event Processing Pipeline\nEventBridge: Event routing and filtering with \u0026ldquo;OrderEventBus\u0026rdquo; rule CloudWatch + X-RAY: Monitoring and distributed tracing Routes events to appropriate processors Event Storage \u0026amp; Replay\nEventStore (DynamoDB): Stores immutable events Replay Lambda: Replays events when state rebuild is needed ReadModel (DynamoDB): Materialized views optimized for queries Query Processing\nQuery Lambda: Handles read operations from ReadModel SNS: Notifications and event publishing 🔧 Serverless Technologies Used Service Role AWS Lambda Command/Query Handlers EventBridge Event Bus \u0026amp; Routing DynamoDB Event Store \u0026amp; Read Models API Gateway REST API Endpoints S3 + CloudFront Static Website Hosting CloudWatch Monitoring \u0026amp; Logging X-Ray Distributed Tracing SNS Pub/Sub Messaging 🚀 By the end of this hands-on workshop, you\u0026rsquo;ll have practical experience building resilient, audit-compliant systems using Event Sourcing and CQRS patterns, and the confidence to architect your own serverless applications that handle complex business workflows with complete traceability.\n"
},
{
	"uri": "//localhost:1313/8-testing/8.1-testing/",
	"title": "Testing Application",
	"tags": [],
	"description": "",
	"content": "Step 1: Access the Application Open your web browser and navigate to your S3 static website URL. You should see the FAST FOOD application homepage. Click on Place order to start testing the ordering functionality. Step 2: Place a Test Order In the menu section, select an item (e.g., Coca Cola).\nClick the + button to add it to your cart.\nFill in the customer information:\nName: ho chi khanh Phone: 0937026887 Address: quan 9 Click Checkout to place the order.\nStep 3: Verify Order Confirmation After placing the order, you should see the order status change to Confirmed. Note the order ID (e.g., Order #23b07487\u0026hellip;) and timestamp. The order should show as \u0026ldquo;Order confirmed and being prepared\u0026rdquo;. Step 4: Check Email Notification Check the email inbox associated with your SNS subscription.\nYou should receive an email with subject: [ADMIN] New Order Placed - #23b07487\nThe email should contain:\nOrder ID: 23b07487-9bc8-47b3-a013-86238ec216fd Customer: ho chi khanh Phone: 0937026887 Total: $2.99 Status: PLACED Step 5: Test Order Confirmation On the order details page, you should see the order status as Pending. You should see \u0026ldquo;Order is awaiting your action\u0026rdquo; message. Click the Confirm Order button to confirm the order. Notice there\u0026rsquo;s also a Cancel Order option available. Step 6: Test Order Management You can test the order management functionality by:\nClicking Cancel Order to cancel the order Clicking Confirm Order to confirm receipt Each action should trigger appropriate status updates and notifications.\nStep 7: Check Database Records Go to AWS Console and navigate to DynamoDB. Click on Explore items to view the stored data. Check EventStore Table Check OrderReadModel Table Check CustomerReadModel Table "
},
{
	"uri": "//localhost:1313/5-setupeventbridge/5.1-customeventbus/5.1.1-configure-eventbridge-rules/",
	"title": "Configure EventBridge Rules",
	"tags": [],
	"description": "",
	"content": "In this section, we will create an EventBridge rule that supports our Event Sourcing architecture by capturing domain events from our custom event bus. This rule will route order events (OrderPlaced, OrderConfirmed, OrderCancelled) to our Lambda function, which will process these events to update read models and maintain the event store - a key component of Event Sourcing pattern.\nStep 1: Navigate to EventBridge Rules In the Amazon EventBridge console, click Rules in the left navigation panel. Click Create rule. Step 2: Define Rule Details Name: OrderEventProcessingRule Description: Process all order events Event bus: Select FastFoodOrderBus from the dropdown Rule type: Select Rule with an event pattern Click Next. Step 3: Build Event Pattern Creation method: Select Custom pattern (JSON editor) In the Event pattern text area, enter the following JSON: { \u0026#34;source\u0026#34;: [\u0026#34;fastfood.orders\u0026#34;], \u0026#34;detail-type\u0026#34;: [ \u0026#34;OrderPlaced\u0026#34;, \u0026#34;OrderConfirmed\u0026#34;, \u0026#34;OrderCancelled\u0026#34; ] } Verify that JSON is valid indicator shows a green checkmark. Click Next. Step 4: Configure Target Target type: Select AWS service Select a service: Choose Lambda function Function: Select OrderEventProcessor from the dropdown Leave other settings as default. Click Next. Step 5: Configure Tags (Optional) This step is optional. You can add tags to organize and track your EventBridge rule. Click Next to proceed. Step 6: Review and Create Review all the configuration details:\nRule name: OrderEventProcessingRule Event bus: FastFoodOrderBus Event pattern: Captures fastfood.orders events Target: OrderEventProcessor Lambda function Click Create rule. ✅ Result: The EventBridge rule is successfully created and will automatically route order events from the FastFoodOrderBus to the OrderEventProcessor Lambda function for processing.\nCreate StateReconstructionRule Now we\u0026rsquo;ll create a second rule for handling state reconstruction requests.\nStep 7: Create Second Rule Click Create rule again to create another rule. Configure the rule details: Name: StateReconstructionRule Description: Handle state reconstruction requests Event bus: Select FastFoodOrderBus from the dropdown Rule type: Select Rule with an event pattern Click Next. Step 8: Build Event Pattern for State Reconstruction Creation method: Select Custom pattern (JSON editor) In the Event pattern text area, enter the following JSON: { \u0026#34;source\u0026#34;: [\u0026#34;fastfood.orders\u0026#34;], \u0026#34;detail-type\u0026#34;: [ \u0026#34;OrderPlaced\u0026#34;, \u0026#34;OrderConfirmed\u0026#34;, \u0026#34;OrderCancelled\u0026#34; ] } Verify that JSON is valid indicator shows a green checkmark. Click Next.\nStep 9: Configure Target for State Reconstruction Target type: Select AWS service Select a service: Choose Lambda function Function: Select StateReconstructionHandler from the dropdown Leave other settings as default. Click Next. Step 10: Review and Create State Reconstruction Rule Review all the configuration details:\nRule name: StateReconstructionRule Event bus: FastFoodOrderBus Event pattern: Captures fastfood.orders events Target: StateReconstructionHandler Lambda function 📌 Important: In the screenshot above, the Rule ARN is just an example.\nPlease copy the Rule ARN from your StateReconstructionRule in your AWS account.\nYou can find it in the EventBridge console → Click your rule → Rule ARN (highlighted in the red box).\nConfigure Lambda Function Permissions After creating the EventBridge rule, we need to ensure our Lambda function has the proper permissions to be invoked by EventBridge.\nNavigate to Lambda Console → Functions → StateReconstructionHandler\nGo to the Configuration tab → Permissions Go to Resource-based policy statements → Add permissions Add EventBridge Invoke Permission\nService: Select EventBridge (CloudWatch Events) Statement ID: AllowEventBridgeInvokeStateReconstruction Principal: events.amazonaws.com Source ARN: arn:aws:events:ap-southeast-1:218451864254:rule/FastFoodOrderBus/StateReconstructionRule Action: lambda:InvokeFunction** The ARN below is just an example. Replace it with the ARN of the StateReconstructionRule that you created in your AWS account.\n9. Click Save to apply the permissions.\nThis permission configuration is for the StateReconstructionHandler Lambda function. The setup is the same as in the OrderEventProcessor permission configuration earlier, except for the function name and the EventBridge rule it is linked to.\nEvent Sourcing Context: This rule is essential for our Event Sourcing implementation. When domain events (OrderPlaced, OrderConfirmed, OrderCancelled) are published to the FastFoodOrderBus, they represent state changes in our system. The Lambda function will process these events to: Store them in the event store (DynamoDB) Update read models for queries Potentially trigger side effects or notifications. This enables us to reconstruct the application state from the sequence of events - the core principle of Event Sourcing.\n"
},
{
	"uri": "//localhost:1313/3-eventstore/3.2-create-orderreadmodel-table/",
	"title": "Create OrderReadModel Table",
	"tags": [],
	"description": "",
	"content": "Repeat the same steps as in the EventStore creation\nStep 1: Create New Table In the DynamoDB Console, click Create table. Table name: OrderReadModel Partition key: orderId (String) Select Default settings. Click Create table. ✅ Result: The OrderReadModel table is ready for storing order data.\n"
},
{
	"uri": "//localhost:1313/6-configapigateway/6.2-enable-cors/",
	"title": "Enable CORS",
	"tags": [],
	"description": "",
	"content": "\rIn this step, we will enable Cross-Origin Resource Sharing (CORS) on our API Gateway resources. This allows web applications hosted on different domains to securely call our API endpoints.\nStep 1: Enable CORS for Each Resource Perform the following steps for each of these resources:\n/orders /orders/{id} /orders/confirm /orders/cancel /menu /customers /reconstruct /reconstruct/order /reconstruct/all Select the resource in the API Gateway console. Click → Enable CORS.\nConfigure the CORS settings as follows: Access-Control-Allow-Origin: * Access-Control-Allow-Headers: Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token Access-Control-Allow-Methods: Select all available HTTP methods. Click Enable CORS and replace existing CORS headers. Repeat these steps for each resource to ensure that CORS is properly configured across your entire API.\n"
},
{
	"uri": "//localhost:1313/4-deploylambda/4.2.-implementfunctionordereventprocessor/",
	"title": "Implement OrderEventProcessor",
	"tags": [],
	"description": "",
	"content": "Next, we will create the OrderEventProcessor Lambda function, which listens to order events and updates the OrderReadModel accordingly.\nThe steps to create this function are similar to those in the previous section.\nStep 1: Create Lambda Function Select Author from scratch. Enter the function name: OrderEventProcessor. Choose Runtime: Python 3.12. Choose Architecture: x86_64. select Use an existing role and pick EventSourcingLambdaRole. Click Create function. Step 2: Implement Function Code Replace the default code with the following: import json import boto3 from decimal import Decimal from datetime import datetime # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) sns = boto3.client(\u0026#39;sns\u0026#39;) # DynamoDB tables order_table = dynamodb.Table(\u0026#39;OrderReadModel\u0026#39;) customer_table = dynamodb.Table(\u0026#39;CustomerReadModel\u0026#39;) # SNS Topic ARN - Replace with your actual SNS topic ARN SNS_TOPIC_ARN = \u0026#39;arn:aws:sns:ap-southeast-1:218451864254:OrderNotifications\u0026#39; def lambda_handler(event, context): try: print(f\u0026#34;Received event: {json.dumps(event)}\u0026#34;) # Handle EventBridge events if \u0026#39;detail-type\u0026#39; in event and \u0026#39;detail\u0026#39; in event: process_eventbridge_event(event) # Handle direct invocation or other event sources elif \u0026#39;Records\u0026#39; in event: for record in event[\u0026#39;Records\u0026#39;]: if \u0026#39;eventbridge\u0026#39; in record.get(\u0026#39;eventSource\u0026#39;, \u0026#39;\u0026#39;): process_eventbridge_event(json.loads(record[\u0026#39;body\u0026#39;])) else: # Direct EventBridge invocation process_eventbridge_event(event) return {\u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: \u0026#39;Events processed successfully\u0026#39;} except Exception as e: print(f\u0026#34;Error processing events: {str(e)}\u0026#34;) import traceback traceback.print_exc() return {\u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: \u0026#39;Error processing events\u0026#39;} def process_eventbridge_event(event_data): detail_type = event_data.get(\u0026#39;detail-type\u0026#39;) detail = event_data.get(\u0026#39;detail\u0026#39;, {}) print(f\u0026#34;Processing event type: {detail_type}\u0026#34;) print(f\u0026#34;Event detail: {detail}\u0026#34;) if detail_type == \u0026#39;OrderPlaced\u0026#39;: handle_order_placed(detail) elif detail_type == \u0026#39;OrderConfirmed\u0026#39;: handle_order_confirmed(detail) elif detail_type == \u0026#39;OrderCancelled\u0026#39;: handle_order_cancelled(detail) else: print(f\u0026#34;Unknown event type: {detail_type}\u0026#34;) def handle_order_placed(detail): try: # Convert float values back to Decimal for DynamoDB items = [] for item in detail.get(\u0026#39;items\u0026#39;, []): items.append({ \u0026#39;itemId\u0026#39;: item[\u0026#39;itemId\u0026#39;], \u0026#39;name\u0026#39;: item[\u0026#39;name\u0026#39;], \u0026#39;price\u0026#39;: Decimal(str(item[\u0026#39;price\u0026#39;])), \u0026#39;quantity\u0026#39;: item[\u0026#39;quantity\u0026#39;], \u0026#39;total\u0026#39;: Decimal(str(item[\u0026#39;total\u0026#39;])) }) # Create order record in read model order_item = { \u0026#39;orderId\u0026#39;: detail[\u0026#39;orderId\u0026#39;], \u0026#39;customerName\u0026#39;: detail[\u0026#39;customerName\u0026#39;], \u0026#39;customerPhone\u0026#39;: detail[\u0026#39;customerPhone\u0026#39;], \u0026#39;customerAddress\u0026#39;: detail[\u0026#39;customerAddress\u0026#39;], \u0026#39;items\u0026#39;: items, \u0026#39;totalAmount\u0026#39;: Decimal(str(detail[\u0026#39;totalAmount\u0026#39;])), \u0026#39;status\u0026#39;: \u0026#39;PLACED\u0026#39;, \u0026#39;createdAt\u0026#39;: detail.get(\u0026#39;timestamp\u0026#39;, datetime.utcnow().isoformat()), \u0026#39;updatedAt\u0026#39;: detail.get(\u0026#39;timestamp\u0026#39;, datetime.utcnow().isoformat()) } order_table.put_item(Item=order_item) print(f\u0026#34;Order {detail[\u0026#39;orderId\u0026#39;]} created in read model\u0026#34;) # Update customer record customer_id = detail[\u0026#39;customerPhone\u0026#39;] # Use phone as customer ID try: customer_table.update_item( Key={\u0026#39;customerId\u0026#39;: customer_id}, UpdateExpression=\u0026#39;SET customerName = :name, customerPhone = :phone, totalOrders = if_not_exists(totalOrders, :zero) + :one, updatedAt = :updated\u0026#39;, ExpressionAttributeValues={ \u0026#39;:name\u0026#39;: detail[\u0026#39;customerName\u0026#39;], \u0026#39;:phone\u0026#39;: detail[\u0026#39;customerPhone\u0026#39;], \u0026#39;:zero\u0026#39;: 0, \u0026#39;:one\u0026#39;: 1, \u0026#39;:updated\u0026#39;: datetime.utcnow().isoformat() } ) print(f\u0026#34;Customer {customer_id} updated\u0026#34;) except Exception as e: print(f\u0026#34;Error updating customer: {str(e)}\u0026#34;) # Gửi thông báo cho admin send_notification( f\u0026#34;[ADMIN] New Order Placed - #{detail[\u0026#39;orderId\u0026#39;][:8]}\u0026#34;, ( f\u0026#34;A new customer order has been placed.\\n\u0026#34; f\u0026#34;Order ID: {detail[\u0026#39;orderId\u0026#39;]}\\n\u0026#34; f\u0026#34;Customer: {detail[\u0026#39;customerName\u0026#39;]}\\n\u0026#34; f\u0026#34;Phone: {detail[\u0026#39;customerPhone\u0026#39;]}\\n\u0026#34; f\u0026#34;Total: ${detail[\u0026#39;totalAmount\u0026#39;]:.2f}\\n\u0026#34; f\u0026#34;Status: PLACED\u0026#34; ) ) except Exception as e: print(f\u0026#34;Error handling OrderPlaced: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def handle_order_confirmed(detail): try: order_table.update_item( Key={\u0026#39;orderId\u0026#39;: detail[\u0026#39;orderId\u0026#39;]}, UpdateExpression=\u0026#39;SET #status = :status, confirmedAt = :confirmed_at, estimatedDelivery = :estimated, updatedAt = :updated\u0026#39;, ExpressionAttributeNames={\u0026#39;#status\u0026#39;: \u0026#39;status\u0026#39;}, ExpressionAttributeValues={ \u0026#39;:status\u0026#39;: \u0026#39;CONFIRMED\u0026#39;, \u0026#39;:confirmed_at\u0026#39;: detail.get(\u0026#39;confirmedAt\u0026#39;), \u0026#39;:estimated\u0026#39;: detail.get(\u0026#39;estimatedDelivery\u0026#39;), \u0026#39;:updated\u0026#39;: datetime.utcnow().isoformat() } ) print(f\u0026#34;Order {detail[\u0026#39;orderId\u0026#39;]} confirmed\u0026#34;) # Gửi thông báo cho admin send_notification( f\u0026#34;[ADMIN] Order Confirmed - #{detail[\u0026#39;orderId\u0026#39;][:8]}\u0026#34;, ( f\u0026#34;Customer order has been confirmed.\\n\u0026#34; f\u0026#34;Order ID: {detail[\u0026#39;orderId\u0026#39;]}\\n\u0026#34; f\u0026#34;Estimated Delivery: {detail.get(\u0026#39;estimatedDelivery\u0026#39;, \u0026#39;TBD\u0026#39;)}\u0026#34; ) ) except Exception as e: print(f\u0026#34;Error handling OrderConfirmed: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def handle_order_cancelled(detail): try: order_table.update_item( Key={\u0026#39;orderId\u0026#39;: detail[\u0026#39;orderId\u0026#39;]}, UpdateExpression=\u0026#39;SET #status = :status, cancelledAt = :cancelled_at, cancelReason = :reason, updatedAt = :updated\u0026#39;, ExpressionAttributeNames={\u0026#39;#status\u0026#39;: \u0026#39;status\u0026#39;}, ExpressionAttributeValues={ \u0026#39;:status\u0026#39;: \u0026#39;CANCELLED\u0026#39;, \u0026#39;:cancelled_at\u0026#39;: detail.get(\u0026#39;cancelledAt\u0026#39;), \u0026#39;:reason\u0026#39;: detail.get(\u0026#39;reason\u0026#39;), \u0026#39;:updated\u0026#39;: datetime.utcnow().isoformat() } ) print(f\u0026#34;Order {detail[\u0026#39;orderId\u0026#39;]} cancelled\u0026#34;) # Gửi thông báo cho admin send_notification( f\u0026#34;[ADMIN] Order Cancelled - #{detail[\u0026#39;orderId\u0026#39;][:8]}\u0026#34;, ( f\u0026#34;Customer order has been cancelled.\\n\u0026#34; f\u0026#34;Order ID: {detail[\u0026#39;orderId\u0026#39;]}\\n\u0026#34; f\u0026#34;Reason: {detail.get(\u0026#39;reason\u0026#39;, \u0026#39;No reason provided\u0026#39;)}\u0026#34; ) ) except Exception as e: print(f\u0026#34;Error handling OrderCancelled: {str(e)}\u0026#34;) import traceback traceback.print_exc() raise def send_notification(subject, message): try: print(f\u0026#34;NOTIFICATION - {subject}: {message}\u0026#34;) sns.publish( TopicArn=SNS_TOPIC_ARN, Subject=str(subject), Message=str(message) ) except Exception as e: print(f\u0026#34;Error sending notification: {str(e)}\u0026#34;) import traceback traceback.print_exc() # Không raise để Lambda tiếp tục chạy Click Deploy to save the function code. ✅ The OrderEventProcessor Lambda function is now ready to process order events and update the read model.\n"
},
{
	"uri": "//localhost:1313/8-testing/8.2-monitoring/",
	"title": "Monitoring with CloudWatch",
	"tags": [],
	"description": "",
	"content": "Step 1: Access CloudWatch Console In the AWS Management Console, search for CloudWatch. Click CloudWatch to open the monitoring service. Step 2: View Log Groups In the CloudWatch console, navigate to Logs → Log groups.\nYou should see 4 log groups created for your Lambda functions:\n/aws/lambda/OrderCommandHandler /aws/lambda/OrderEventProcessor /aws/lambda/OrderQueryHandler /aws/lambda/StateReconstructionHandler Each log group shows the Log class, Retention, and other configuration details. Step 3: Monitor Lambda Function Logs Click on /aws/lambda/StateReconstructionHandler log group.\nYou can see the log group details including:\nCreation time: When the log group was created Retention: Never expire (by default) Stored bytes: Amount of log data stored ARN: Amazon Resource Name for the log group The figure above illustrates the Log events view for the Lambda function StateReconstructionHandler in AWS CloudWatch. Each log entry is displayed in chronological order, containing information about events received from EventBridge (e.g., OrderPlaced, OrderConfirmed, OrderCancelled), the process of rebuilding the order state from the EventStore, and updating the corresponding Read Model. The logs also provide performance metrics such as execution duration, memory usage, and initialization time for the Lambda function. This detailed monitoring enables the development team to verify the correctness of the event processing flow, ensure data consistency, and identify potential performance bottlenecks for optimization.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/",
	"title": "Preparation",
	"tags": [],
	"description": "",
	"content": "In this step, we will prepare the required environment for our workshop, including installing Node.js, setting up the frontend source code, and creating an IAM Role for AWS services.\nContent 2.1. Install Nodejs 2.2. Setup Frontend source 2.3. Create IAM Role\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.2-setup-frontend-source/",
	"title": "Setup Frontend",
	"tags": [],
	"description": "",
	"content": "Set up the Frontend Source Clone the project from GitHub: git clone https://github.com/khanhchi423/fastfood-order-frontend.git 2. Navigate into the project folder: ```bash cd fastfood-order-frontend Install project dependencies using npm: npm install Start the development server: npm run dev If the server runs successfully, you will see an output indicating the app is running, usually at: http://localhost:3000 Open this URL in your browser to view the frontend application. "
},
{
	"uri": "//localhost:1313/7-deployfrontend/7.2-upload-frontend-to-s3/",
	"title": "Upload Frontend to S3",
	"tags": [],
	"description": "",
	"content": "Upload ReactJS Frontend to S3 (Detailed Steps) Step 1: Configure API URL in React Before building the frontend, set up your environment variables in the .env file or directly in your environment:\nVITE_API_BASE_URL=https://0nxpvdebt3.execute-api.ap-southeast-1.amazonaws.com/prod VITE_USE_MOCK_DATA=true Update the config file src/config/config.js to use these environment variables:\nconst config = { // API Configuration API_BASE_URL: import.meta.env.VITE_API_BASE_URL || \u0026#39;https://0nxpvdebt3.execute-api.ap-southeast-1.amazonaws.com/prod\u0026#39;, // Development mode - set to true to use mock data instead of API USE_MOCK_DATA: import.meta.env.VITE_USE_MOCK_DATA === \u0026#39;true\u0026#39; || false, // Other configurations APP_NAME: \u0026#39;FastFood Order System\u0026#39;, APP_VERSION: \u0026#39;1.0.0\u0026#39;, // Request timeout (in milliseconds) REQUEST_TIMEOUT: 10000, // Auto-refresh intervals (in milliseconds) ORDER_REFRESH_INTERVAL: 30000, // 30 seconds MENU_REFRESH_INTERVAL: 300000, // 5 minutes }; export default config; Replace the default API URL (https://0nxpvdebt3.execute-api.ap-southeast-1.amazonaws.com/prod) with the actual API Gateway invoke URL you created for your deployment.\nStep 2: Build the Frontend Run the build command to generate the production-ready files:\nnpm run build Step 3: Upload Build Folder to S3 Open the S3 Console in AWS.\nSelect your frontend S3 bucket.\nClick Upload → Add folder.\nChoose the build folder from your React project.\nUpload all contents inside the build folder.\nTest a website with endpoint. "
},
{
	"uri": "//localhost:1313/7-deployfrontend/7.3-create-cloudfrontdistributionandapplyittothewebsite/",
	"title": "Create Cloudfront Distribution and Apply it to the Website",
	"tags": [],
	"description": "",
	"content": "Create CloudFront Distribution for Global Content Delivery CloudFront is Amazon\u0026rsquo;s content delivery network (CDN) that speeds up distribution of your static and dynamic web content to users worldwide. In this section, we\u0026rsquo;ll create a CloudFront distribution for our React application.\nStep 1: Access CloudFront Service Navigate to the AWS Management Console and search for \u0026ldquo;CloudFront\u0026rdquo; in the search bar. Click on CloudFront to open the service dashboard. Click Create a CloudFront distribution to start the setup process. Step 2: Configure Distribution Settings Distribution Options\nDistribution name: Enter a descriptive name for your distribution: fastfood-react-app Description (optional): Add a brief description: FastFood Order System - React App Distribution type: Select Single website or app since we\u0026rsquo;re deploying a single React application. Custom Domain (Optional) If you have a custom domain, you can configure it here. Otherwise, leave this field empty to use the default CloudFront domain.\nDomain (optional): Leave empty for now or enter your custom domain if you have one. Click Check domain if you entered a custom domain to verify availability. Step 3: Specify Origin Configuration The origin is where CloudFront fetches your content from - in this case, your S3 bucket.\nOrigin type: Select Amazon S3 as we\u0026rsquo;re serving content from our S3 bucket.\nS3 origin: Enter your S3 bucket endpoint: event-sourcing-fastfood-frontend-s3-website-ap-southeast-1.amazonaws.com\nOrigin path (optional): Leave as /path or modify if your content is in a specific folder.\nStep 4: Configure Security Settings Web Application Firewall (WAF) For this tutorial, we\u0026rsquo;ll disable WAF to keep costs minimal:\nWeb Application Firewall (WAF): Select Do not enable security protections. This option is suitable for development and testing environments. For production applications, consider enabling WAF for additional security. Step 5: Review and Create Distribution Review all your configuration settings to ensure they\u0026rsquo;re correct. Click Next to proceed to the final review page. Click Create distribution to deploy your CloudFront distribution. CloudFront distribution deployment typically takes 15-20 minutes to complete. The status will change from \u0026ldquo;Deploying\u0026rdquo; to \u0026ldquo;Enabled\u0026rdquo; once ready.\nUpdate S3 Bucket Policy Navigate back to your S3 bucket: event-sourcing-fastfood-frontend Go to the Permissions tab Click on Bucket policy to edit the existing policy Update the policy to include CloudFront access permissions The updated bucket policy should look like this: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::event-sourcing-fastfood-frontend/*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowCloudFrontServicePrincipal\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;cloudfront.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::event-sourcing-fastfood-frontend/*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:aws:cloudfront::218453064234:distribution/E2MQTT186060K\u0026#34; } } } ] } Click Save changes to apply the updated policy Access Your Application via CloudFront Once the CloudFront distribution is deployed and the bucket policy is updated, you can access your React application through the CloudFront URL. Test the CloudFront Distribution\nCopy the Distribution domain name from your CloudFront console (e.g., d26xve6snn0mdw.cloudfront.net) Open a new browser tab and navigate to your CloudFront URL Verify that your Fast Food System loads correctly You should see your React application with: "
},
{
	"uri": "//localhost:1313/3-eventstore/3.3-create-customerreadmodel-table/",
	"title": "Create CustomerReadModel Table",
	"tags": [],
	"description": "",
	"content": "Step 1: Create New Table In the DynamoDB Console, click Create table. Table name: CustomerReadModel Partition key: customerId (String) Select Default settings. Click Create table. ✅ Result: The CustomerReadModel table is ready for storing customer information.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.3-create-iam-role/",
	"title": "Create IAM Role",
	"tags": [],
	"description": "",
	"content": "Step 1: Open IAM Console In the AWS Management Console, search for IAM. Click on IAM to open the IAM dashboard. Step 2: Create Role Go to Roles → Create role. Under Trusted entity type, select AWS service.\nChoose Lambda as the service.\nClick Next. Click Create Role. "
},
{
	"uri": "//localhost:1313/5-setupeventbridge/5.2-create-sns-topic-for-notifications/",
	"title": "Create SNS Topic for Notifications",
	"tags": [],
	"description": "",
	"content": "In this section, we will create an SNS (Simple Notification Service) Topic to handle notifications triggered by our order events. This topic will serve as a communication hub for broadcasting order status updates to subscribers, supporting our Event Sourcing architecture by providing real-time notifications when domain events occur.\nStep 1: Access SNS Console In the AWS Management Console, search for \u0026ldquo;SNS\u0026rdquo;. Click Simple Notification Service to open the service. Step 2: Create SNS Topic In the SNS console, click Topics in the left navigation panel. Click Create topic. Step 3: Configure Topic Details Type: Select Standard (recommended for high throughput and best-effort message ordering) Name: Enter OrderNotifications Display name: Enter Order Notifications (optional - used for SMS subscriptions) Leave other settings as default for now. Click Create topic. ✅ Result: The OrderNotifications topic is successfully created and ready to handle notifications.\nStep 4: Create Email Subscription Navigate to the newly created OrderNotifications topic. Click Create subscription. Step 5: Configure Subscription Details Topic ARN: This should be auto-populated with your OrderNotifications topic ARN Protocol: Select Email Endpoint: Enter your email address (e.g., your-email@gmail.com) Leave optional settings as default. Click Create subscription. Step 6: Confirm Email Subscription Open your email inbox and look for an email from AWS Notifications – Subscription Confirmation.\nClick Confirm subscription in the email to activate your subscription.\nOnce confirmed, the subscription status will change to Confirmed.\nStep 7: Link SNS Topic ARN to Lambda After creating your SNS topic and confirming the subscription, you need to link it to the OrderEventProcessor Lambda function so it can publish notifications.\nOpen the AWS Lambda Console and navigate to the OrderEventProcessor function. In the Code tab, locate the SNS_TOPIC_ARN variable. Replace the placeholder with the ARN of the SNS topic you created earlier. "
},
{
	"uri": "//localhost:1313/6-configapigateway/6.3-deploy-api/",
	"title": "Deploy API",
	"tags": [],
	"description": "",
	"content": "In this section, we will deploy our configured API Gateway so that it becomes accessible to clients via a public URL.\nStep 1: Deploy API In the API Gateway console, click Actions → Deploy API. Configure the deployment settings: Deployment stage: Select [New Stage]. Stage name: Enter prod. Stage description: Enter Production stage. Deployment description: Enter Initial deployment. Click Deploy. Step 2: Save API URL After deployment, the Invoke URL will be displayed at the top. Copy and save this URL for future use in your client applications.\nExample:\nhttps://your-api-id.execute-api.ap-southeast-1.amazonaws.com/prod "
},
{
	"uri": "//localhost:1313/4-deploylambda/4.3.-implementfunctionorderqueryhandler/",
	"title": "Implement OrderQueryHandler",
	"tags": [],
	"description": "",
	"content": "Next, we will create the OrderQueryHandler Lambda function that handles query requests to retrieve order details from the OrderReadModel.\nThe steps to create this function are similar to the previous sections.\nStep 1: Create Lambda Function Select Author from scratch. Enter the function name: OrderQueryHandler. Choose Runtime: Python 3.12. Choose Architecture: x86_64. Select Use an existing role and pick EventSourcingLambdaRole. Click Create function. Step 2: Implement Function Code Replace the default code with the following: import json import boto3 from boto3.dynamodb.conditions import Key from decimal import Decimal # Initialize DynamoDB dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) order_table = dynamodb.Table(\u0026#39;OrderReadModel\u0026#39;) customer_table = dynamodb.Table(\u0026#39;CustomerReadModel\u0026#39;) menu_items_table = dynamodb.Table(\u0026#39;MenuItems\u0026#39;) class DecimalEncoder(json.JSONEncoder): def default(self, o): if isinstance(o, Decimal): return float(o) return super(DecimalEncoder, self).default(o) def lambda_handler(event, context): try: http_method = event[\u0026#39;httpMethod\u0026#39;] path = event[\u0026#39;path\u0026#39;] query_params = event.get(\u0026#39;queryStringParameters\u0026#39;) or {} print(f\u0026#34;Processing {http_method} {path}\u0026#34;) print(f\u0026#34;Query params: {query_params}\u0026#34;) if path == \u0026#39;/orders\u0026#39; and http_method == \u0026#39;GET\u0026#39;: return handle_get_orders(query_params) elif path.startswith(\u0026#39;/orders/\u0026#39;) and http_method == \u0026#39;GET\u0026#39;: order_id = path.split(\u0026#39;/\u0026#39;)[-1] return handle_get_order(order_id) elif path == \u0026#39;/menu\u0026#39; and http_method == \u0026#39;GET\u0026#39;: return handle_get_menu() elif path == \u0026#39;/customers\u0026#39; and http_method == \u0026#39;GET\u0026#39;: return handle_get_customers(query_params) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Endpoint not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;}) def handle_get_orders(query_params): try: # Get all orders (in production, you\u0026#39;d want pagination) response = order_table.scan( Limit=50 # Limit to 50 orders ) orders = response.get(\u0026#39;Items\u0026#39;, []) # Sort by createdAt descending orders.sort(key=lambda x: x.get(\u0026#39;createdAt\u0026#39;, \u0026#39;\u0026#39;), reverse=True) return build_response(200, { \u0026#39;orders\u0026#39;: orders, \u0026#39;count\u0026#39;: len(orders) }) except Exception as e: print(f\u0026#34;Error getting orders: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get orders\u0026#39;}) def handle_get_order(order_id): try: response = order_table.get_item(Key={\u0026#39;orderId\u0026#39;: order_id}) if \u0026#39;Item\u0026#39; in response: return build_response(200, response[\u0026#39;Item\u0026#39;]) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Order not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error getting order: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get order\u0026#39;}) def handle_get_menu(): try: response = menu_items_table.scan() items = response.get(\u0026#39;Items\u0026#39;, []) # Filter only available items available_items = [item for item in items if item.get(\u0026#39;available\u0026#39;, False)] return build_response(200, { \u0026#39;items\u0026#39;: available_items, \u0026#39;count\u0026#39;: len(available_items) }) except Exception as e: print(f\u0026#34;Error getting menu: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get menu\u0026#39;}) def handle_get_customers(query_params): try: response = customer_table.scan( Limit=50 # Limit to 50 customers ) customers = response.get(\u0026#39;Items\u0026#39;, []) return build_response(200, { \u0026#39;customers\u0026#39;: customers, \u0026#39;count\u0026#39;: len(customers) }) except Exception as e: print(f\u0026#34;Error getting customers: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to get customers\u0026#39;}) def build_response(status_code, body): return { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, PUT, DELETE, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(body, cls=DecimalEncoder, default=str) } Click Deploy to save the function code. ✅ The OrderQueryHandler Lambda function is now ready to handle order query requests.\n"
},
{
	"uri": "//localhost:1313/3-eventstore/",
	"title": "Setup Event Store &amp; Read Models (DynamoDB)",
	"tags": [],
	"description": "",
	"content": "In this step, we will create the DynamoDB tables required for our Event Sourcing architecture and seed initial data for the MenuItems table.\nContent 3.1. Create EventStore Table 3.2. Create OrderReadModel Table 3.3. Create CustomerReadModel Table 3.4. Create MenuItems Table 3.5. Seed Data for MenuItems\n"
},
{
	"uri": "//localhost:1313/3-eventstore/3.4-create-menuitems-table/",
	"title": "Create MenuItems Table",
	"tags": [],
	"description": "",
	"content": "Step 1: Create New Table In the DynamoDB Console, click Create table. Table name: MenuItems Partition key: itemId (String) Select Default settings. Click Create table. ✅ Result: The MenuItems table is ready for storing menu data.\n"
},
{
	"uri": "//localhost:1313/4-deploylambda/",
	"title": "Deploy Lambda Functions",
	"tags": [],
	"description": "",
	"content": "In this step, we will deploy the four core Lambda functions that form the backbone of our Event Sourcing ordering system.\nContent 4.1. Deploy OrderCommandHandler Function\n4.2. Deploy OrderEventProcessor Function\n4.3. Deploy OrderQueryHandler Function\n4.4. Deploy State Reconstruction Handler Function\n"
},
{
	"uri": "//localhost:1313/4-deploylambda/4.4.-implementfunctionstatereconstructionhandler/",
	"title": "Implement State Reconstruction Handler",
	"tags": [],
	"description": "",
	"content": "Finally, we will implement the State Reconstruction Handler Lambda function. This function rebuilds the current state of an order by replaying events from the Event Store, ensuring our system\u0026rsquo;s state is consistent with the sequence of events.\nThe creation steps are similar to the previous Lambda functions.\nStep 1: Create Lambda Function Select Author from scratch. Enter the function name: StateReconstructionHandler. Choose Runtime: Python 3.12. Choose Architecture: x86_64. Select Use an existing role and pick EventSourcingLambdaRole. Click Create function. Step 2: Implement Function Code Replace the default code with the following: import json import boto3 from boto3.dynamodb.conditions import Key from decimal import Decimal from datetime import datetime # Initialize DynamoDB dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) event_store_table = dynamodb.Table(\u0026#39;EventStore\u0026#39;) order_table = dynamodb.Table(\u0026#39;OrderReadModel\u0026#39;) class DecimalEncoder(json.JSONEncoder): def default(self, o): if isinstance(o, Decimal): return float(o) return super(DecimalEncoder, self).default(o) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34; State Reconstruction Handler - HTTP request: rebuild theo API path - EventBridge event: rebuild ngay cho order liên quan \u0026#34;\u0026#34;\u0026#34; try: print(\u0026#34;Received event:\u0026#34;, json.dumps(event)) http_method = None path = None body = {} # Trường hợp API Gateway REST API if \u0026#39;httpMethod\u0026#39; in event: http_method = event[\u0026#39;httpMethod\u0026#39;] path = event.get(\u0026#39;path\u0026#39;) body = json.loads(event.get(\u0026#39;body\u0026#39;) or \u0026#34;{}\u0026#34;) # Trường hợp API Gateway HTTP API (v2 payload) elif event.get(\u0026#39;requestContext\u0026#39;, {}).get(\u0026#39;http\u0026#39;, {}).get(\u0026#39;method\u0026#39;): http_method = event[\u0026#39;requestContext\u0026#39;][\u0026#39;http\u0026#39;][\u0026#39;method\u0026#39;] path = event.get(\u0026#39;rawPath\u0026#39;) body = json.loads(event.get(\u0026#39;body\u0026#39;) or \u0026#34;{}\u0026#34;) # Trường hợp EventBridge event elif event.get(\u0026#34;detail-type\u0026#34;) in [\u0026#34;OrderPlaced\u0026#34;, \u0026#34;OrderConfirmed\u0026#34;, \u0026#34;OrderCancelled\u0026#34;]: order_id = event.get(\u0026#34;detail\u0026#34;, {}).get(\u0026#34;orderId\u0026#34;) if not order_id: print(\u0026#34;No orderId in event, skipping reconstruction.\u0026#34;) return build_response(400, {\u0026#34;error\u0026#34;: \u0026#34;orderId not found in event\u0026#34;}) print(f\u0026#34;Rebuilding state for orderId from EventBridge: {order_id}\u0026#34;) events = get_events_for_order(order_id) if not events: return build_response(404, {\u0026#34;error\u0026#34;: f\u0026#34;No events found for order {order_id}\u0026#34;}) reconstructed_state = reconstruct_order_state(events) update_read_model(reconstructed_state) return build_response(200, { \u0026#34;message\u0026#34;: f\u0026#34;State rebuilt from EventBridge event for order {order_id}\u0026#34;, \u0026#34;orderId\u0026#34;: order_id, \u0026#34;eventsProcessed\u0026#34;: len(events), \u0026#34;reconstructedState\u0026#34;: reconstructed_state }) else: print(\u0026#34;Unknown event source, skipping.\u0026#34;) return build_response(200, {\u0026#34;message\u0026#34;: \u0026#34;Event ignored\u0026#34;}) # Xử lý HTTP request như cũ print(f\u0026#34;Processing {http_method} {path}\u0026#34;) if path == \u0026#39;/reconstruct/order\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_reconstruct_order(body) elif path == \u0026#39;/reconstruct/all\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_reconstruct_all_orders(body) elif path == \u0026#39;/reconstruct/validate\u0026#39; and http_method == \u0026#39;POST\u0026#39;: return handle_validate_reconstruction(body) else: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;Endpoint not found\u0026#39;}) except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) import traceback traceback.print_exc() return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;}) def handle_reconstruct_order(body): \u0026#34;\u0026#34;\u0026#34;Reconstruct a single order from events\u0026#34;\u0026#34;\u0026#34; order_id = body.get(\u0026#39;orderId\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;orderId is required\u0026#39;}) try: # Get all events for this order events = get_events_for_order(order_id) if not events: return build_response(404, {\u0026#39;error\u0026#39;: \u0026#39;No events found for order\u0026#39;}) # Reconstruct state from events reconstructed_state = reconstruct_order_state(events) # Update read model update_read_model(reconstructed_state) return build_response(200, { \u0026#39;message\u0026#39;: \u0026#39;Order state reconstructed successfully\u0026#39;, \u0026#39;orderId\u0026#39;: order_id, \u0026#39;eventsProcessed\u0026#39;: len(events), \u0026#39;reconstructedState\u0026#39;: reconstructed_state }) except Exception as e: print(f\u0026#34;Error reconstructing order {order_id}: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to reconstruct order\u0026#39;}) def handle_reconstruct_all_orders(body): \u0026#34;\u0026#34;\u0026#34;Reconstruct all orders from events\u0026#34;\u0026#34;\u0026#34; max_orders = body.get(\u0026#39;maxOrders\u0026#39;, 100) # Limit for safety try: # Get all unique aggregate IDs from event store response = event_store_table.scan( ProjectionExpression=\u0026#39;aggregateId\u0026#39;, Limit=max_orders ) order_ids = list(set([item[\u0026#39;aggregateId\u0026#39;] for item in response.get(\u0026#39;Items\u0026#39;, [])])) reconstructed_orders = [] errors = [] for order_id in order_ids: try: events = get_events_for_order(order_id) if events: reconstructed_state = reconstruct_order_state(events) update_read_model(reconstructed_state) reconstructed_orders.append({ \u0026#39;orderId\u0026#39;: order_id, \u0026#39;eventsProcessed\u0026#39;: len(events) }) except Exception as e: errors.append({ \u0026#39;orderId\u0026#39;: order_id, \u0026#39;error\u0026#39;: str(e) }) return build_response(200, { \u0026#39;message\u0026#39;: f\u0026#39;Reconstructed {len(reconstructed_orders)} orders\u0026#39;, \u0026#39;reconstructedOrders\u0026#39;: reconstructed_orders, \u0026#39;errors\u0026#39;: errors }) except Exception as e: print(f\u0026#34;Error reconstructing all orders: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to reconstruct orders\u0026#39;}) def handle_validate_reconstruction(body): \u0026#34;\u0026#34;\u0026#34;Validate reconstruction by comparing with current read model\u0026#34;\u0026#34;\u0026#34; order_id = body.get(\u0026#39;orderId\u0026#39;) if not order_id: return build_response(400, {\u0026#39;error\u0026#39;: \u0026#39;orderId is required\u0026#39;}) try: # Get current read model state current_state = order_table.get_item(Key={\u0026#39;orderId\u0026#39;: order_id}).get(\u0026#39;Item\u0026#39;) # Get reconstructed state from events events = get_events_for_order(order_id) reconstructed_state = reconstruct_order_state(events) # Compare states validation_result = compare_states(current_state, reconstructed_state) return build_response(200, { \u0026#39;orderId\u0026#39;: order_id, \u0026#39;isValid\u0026#39;: validation_result[\u0026#39;isValid\u0026#39;], \u0026#39;differences\u0026#39;: validation_result[\u0026#39;differences\u0026#39;], \u0026#39;currentState\u0026#39;: current_state, \u0026#39;reconstructedState\u0026#39;: reconstructed_state }) except Exception as e: print(f\u0026#34;Error validating reconstruction: {str(e)}\u0026#34;) return build_response(500, {\u0026#39;error\u0026#39;: \u0026#39;Failed to validate reconstruction\u0026#39;}) def get_events_for_order(order_id): \u0026#34;\u0026#34;\u0026#34;Get all events for a specific order, sorted by timestamp\u0026#34;\u0026#34;\u0026#34; try: response = event_store_table.query( IndexName=\u0026#39;AggregateIndex\u0026#39;, # Assuming GSI on aggregateId KeyConditionExpression=Key(\u0026#39;aggregateId\u0026#39;).eq(order_id), ScanIndexForward=True # Sort by timestamp ascending ) events = response.get(\u0026#39;Items\u0026#39;, []) # Sort by timestamp to ensure correct order events.sort(key=lambda x: x.get(\u0026#39;timestamp\u0026#39;, \u0026#39;\u0026#39;)) return events except Exception as e: print(f\u0026#34;Error getting events for order {order_id}: {str(e)}\u0026#34;) # Fallback to scan if GSI doesn\u0026#39;t exist response = event_store_table.scan( FilterExpression=Key(\u0026#39;aggregateId\u0026#39;).eq(order_id) ) events = response.get(\u0026#39;Items\u0026#39;, []) events.sort(key=lambda x: x.get(\u0026#39;timestamp\u0026#39;, \u0026#39;\u0026#39;)) return events def reconstruct_order_state(events): \u0026#34;\u0026#34;\u0026#34;Reconstruct order state by replaying events\u0026#34;\u0026#34;\u0026#34; state = { \u0026#39;orderId\u0026#39;: None, \u0026#39;status\u0026#39;: None, \u0026#39;customerName\u0026#39;: None, \u0026#39;customerPhone\u0026#39;: None, \u0026#39;customerAddress\u0026#39;: None, \u0026#39;items\u0026#39;: [], \u0026#39;totalAmount\u0026#39;: Decimal(\u0026#39;0\u0026#39;), \u0026#39;createdAt\u0026#39;: None, \u0026#39;updatedAt\u0026#39;: None, \u0026#39;confirmedAt\u0026#39;: None, \u0026#39;cancelledAt\u0026#39;: None, \u0026#39;cancelReason\u0026#39;: None, \u0026#39;estimatedDelivery\u0026#39;: None, \u0026#39;eventHistory\u0026#39;: [] } for event in events: event_type = event.get(\u0026#39;eventType\u0026#39;) event_data = event.get(\u0026#39;eventData\u0026#39;, {}) timestamp = event.get(\u0026#39;timestamp\u0026#39;) # Track event history state[\u0026#39;eventHistory\u0026#39;].append({ \u0026#39;eventType\u0026#39;: event_type, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;eventId\u0026#39;: event.get(\u0026#39;eventId\u0026#39;) }) if event_type == \u0026#39;OrderPlaced\u0026#39;: state[\u0026#39;orderId\u0026#39;] = event_data.get(\u0026#39;orderId\u0026#39;) state[\u0026#39;customerName\u0026#39;] = event_data.get(\u0026#39;customerName\u0026#39;) state[\u0026#39;customerPhone\u0026#39;] = event_data.get(\u0026#39;customerPhone\u0026#39;) state[\u0026#39;customerAddress\u0026#39;] = event_data.get(\u0026#39;customerAddress\u0026#39;) state[\u0026#39;items\u0026#39;] = event_data.get(\u0026#39;items\u0026#39;, []) state[\u0026#39;totalAmount\u0026#39;] = Decimal(str(event_data.get(\u0026#39;totalAmount\u0026#39;, 0))) state[\u0026#39;status\u0026#39;] = \u0026#39;PLACED\u0026#39; state[\u0026#39;createdAt\u0026#39;] = timestamp state[\u0026#39;updatedAt\u0026#39;] = timestamp elif event_type == \u0026#39;OrderConfirmed\u0026#39;: state[\u0026#39;status\u0026#39;] = \u0026#39;CONFIRMED\u0026#39; state[\u0026#39;confirmedAt\u0026#39;] = event_data.get(\u0026#39;confirmedAt\u0026#39;) state[\u0026#39;estimatedDelivery\u0026#39;] = event_data.get(\u0026#39;estimatedDelivery\u0026#39;) state[\u0026#39;updatedAt\u0026#39;] = timestamp elif event_type == \u0026#39;OrderCancelled\u0026#39;: state[\u0026#39;status\u0026#39;] = \u0026#39;CANCELLED\u0026#39; state[\u0026#39;cancelledAt\u0026#39;] = event_data.get(\u0026#39;cancelledAt\u0026#39;) state[\u0026#39;cancelReason\u0026#39;] = event_data.get(\u0026#39;reason\u0026#39;) state[\u0026#39;updatedAt\u0026#39;] = timestamp # Add more event types as needed return state def update_read_model(state): \u0026#34;\u0026#34;\u0026#34;Update the read model with reconstructed state\u0026#34;\u0026#34;\u0026#34; try: # Remove event history for read model read_model_state = {k: v for k, v in state.items() if k != \u0026#39;eventHistory\u0026#39;} order_table.put_item(Item=read_model_state) print(f\u0026#34;Updated read model for order {state[\u0026#39;orderId\u0026#39;]}\u0026#34;) except Exception as e: print(f\u0026#34;Error updating read model: {str(e)}\u0026#34;) raise def compare_states(current_state, reconstructed_state): \u0026#34;\u0026#34;\u0026#34;Compare current read model state with reconstructed state\u0026#34;\u0026#34;\u0026#34; differences = [] if not current_state: return { \u0026#39;isValid\u0026#39;: False, \u0026#39;differences\u0026#39;: [\u0026#39;Current state not found in read model\u0026#39;] } # Remove event history from comparison reconstructed_compare = {k: v for k, v in reconstructed_state.items() if k != \u0026#39;eventHistory\u0026#39;} # Compare key fields compare_fields = [\u0026#39;orderId\u0026#39;, \u0026#39;status\u0026#39;, \u0026#39;customerName\u0026#39;, \u0026#39;customerPhone\u0026#39;, \u0026#39;totalAmount\u0026#39;, \u0026#39;createdAt\u0026#39;, \u0026#39;confirmedAt\u0026#39;, \u0026#39;cancelledAt\u0026#39;] for field in compare_fields: current_value = current_state.get(field) reconstructed_value = reconstructed_compare.get(field) # Handle Decimal comparison if isinstance(current_value, Decimal) and isinstance(reconstructed_value, Decimal): if current_value != reconstructed_value: differences.append(f\u0026#34;{field}: current={current_value}, reconstructed={reconstructed_value}\u0026#34;) elif str(current_value) != str(reconstructed_value): differences.append(f\u0026#34;{field}: current={current_value}, reconstructed={reconstructed_value}\u0026#34;) return { \u0026#39;isValid\u0026#39;: len(differences) == 0, \u0026#39;differences\u0026#39;: differences } def build_response(status_code, body): return { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, PUT, DELETE, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(body, cls=DecimalEncoder, default=str) } Click Deploy to save the function code. ✅ The StateReconstructionHandler Lambda function is now ready to reconstruct order state by replaying events.\n"
},
{
	"uri": "//localhost:1313/5-setupeventbridge/",
	"title": "Implement EventBridge Pipeline",
	"tags": [],
	"description": "",
	"content": "In this section, we will set up the EventBridge infrastructure to support the Event Sourcing architecture of our fast food ordering system. This involves creating a dedicated custom Event Bus to capture and route all domain events related to orders, such as OrderPlaced, OrderConfirmed, and OrderCancelled.\nBy defining precise event rules, we ensure that each event is delivered to the appropriate Lambda functions responsible for processing and updating the system’s state asynchronously. Additionally, we will create an SNS Topic to broadcast notifications triggered by these events.\nThis EventBridge pipeline is a crucial component of our Event Sourcing design, enabling reliable, decoupled, and real-time event-driven processing, which allows the system to reconstruct state from events and respond promptly to changes.\nContent: 5.1 Custom Event Bus 5.1.1 Configure EventBridge Rules 5.2 Create SNS Topic for Notifications "
},
{
	"uri": "//localhost:1313/3-eventstore/3.5-seed-data-menuitems/",
	"title": "Seed Data for MenuItems",
	"tags": [],
	"description": "",
	"content": "Step 1: Open MenuItems Table Go to MenuItems table in DynamoDB Console. Click Explore table items. Click Create item. Step 2: Add Menu Items Now, let\u0026rsquo;s populate the MenuItems table with some sample data. We’ll insert each item individually through the DynamoDB Console.\nThis method is intended for quickly adding sample data for demonstration purposes only.\nOn the Create item page, click JSON view in the top-right corner to switch from Form view to JSON mode. Copy and paste the JSON for each menu item below into the editor, then click Create item to save it. Repeat the process for all three items. Item 1 - Pizza:\n{ \u0026#34;itemId\u0026#34;: \u0026#34;pizza-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Pizza Margherita\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Classic pizza with tomato sauce, mozzarella, and basil\u0026#34;, \u0026#34;price\u0026#34;: 12.99, \u0026#34;category\u0026#34;: \u0026#34;Pizza\u0026#34;, \u0026#34;available\u0026#34;: true, \u0026#34;image\u0026#34;: \u0026#34;https://digiticket.vn/blog/wp-content/uploads/2021/09/pizza-hut-5.jpg\u0026#34; } Item 2 - Burger:\n{ \u0026#34;itemId\u0026#34;: \u0026#34;burger-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Beef Burger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Juicy beef patty with lettuce, tomato, and cheese\u0026#34;, \u0026#34;price\u0026#34;: 8.99, \u0026#34;category\u0026#34;: \u0026#34;Burger\u0026#34;, \u0026#34;available\u0026#34;: true, \u0026#34;image\u0026#34;: \u0026#34;https://i-kinhdoanh.vnecdn.net/2022/08/25/image001-9906-1661419989.jpg\u0026#34; } Item 3 - Drink:\n{ \u0026#34;itemId\u0026#34;: \u0026#34;drink-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Coca Cola\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Classic cola drink\u0026#34;, \u0026#34;price\u0026#34;: 2.99, \u0026#34;category\u0026#34;: \u0026#34;Drink\u0026#34;, \u0026#34;available\u0026#34;: true, \u0026#34;image\u0026#34;: \u0026#34;https://assets.xoimoc.com/responsive-images/md/products/cocacola.png\u0026#34; } JSON view is quicker for bulk entry, while Form view is handy for checking values and types visually.\nOnce all three items are created, return to Explore table items. You should now see the table populated with your seed data: Want to speed up seeding multiple items?\nInstead of creating each record manually in the console, you can use the BatchWriteItem API or AWS CLI to insert many items at once.\n"
},
{
	"uri": "//localhost:1313/6-configapigateway/",
	"title": "Config API Gateway",
	"tags": [],
	"description": "",
	"content": "In this section, we will configure Amazon API Gateway to serve as the front door for our fast food ordering system. API Gateway will act as the RESTful interface that clients use to interact with our Event Sourcing architecture, providing secure and scalable access to our Lambda functions. We will create a new API Gateway that exposes endpoints for order management operations such as creating orders, retrieving order status, and handling customer requests. The API Gateway will integrate seamlessly with our Lambda functions, which in turn publish events to our EventBridge pipeline. Additionally, we will enable Cross-Origin Resource Sharing (CORS) to allow web applications from different domains to interact with our API, ensuring compatibility with modern web development practices. Finally, we will deploy the API to make it accessible to external clients. This API Gateway configuration is essential for providing a clean, RESTful interface to our event-driven architecture, enabling clients to trigger domain events while maintaining proper separation of concerns between the presentation layer and our Event Sourcing implementation.\nContent: 6.1 Create New API Gateway 6.2 Enable CORS 6.3 Deploy API "
},
{
	"uri": "//localhost:1313/7-deployfrontend/",
	"title": "Deploy Frontend Application",
	"tags": [],
	"description": "",
	"content": "In this section, we will prepare and deploy the frontend application for our FastFood Order System. This includes:\nConfiguring necessary environment variables. Building the frontend source code. Deploying the built files to an S3 bucket for static hosting. Setting up Amazon CloudFront as a CDN to deliver the frontend assets efficiently and securely. The following subsections will guide you through each step, from environment setup to deployment and CDN configuration.\nContent: 7.1 Create S3 bucket 7.2 Upload Frontend to S3 7.3 Create Cloudfront Distribution and Apply it to the Website "
},
{
	"uri": "//localhost:1313/8-testing/",
	"title": "Testing &amp; Monitoring",
	"tags": [],
	"description": "",
	"content": "In this section, we will validate the functionality of our FastFood Order System and implement monitoring solutions to ensure optimal performance. This includes:\nConducting comprehensive testing of both frontend and backend components to verify system functionality. Setting up monitoring and logging solutions to track application performance, user interactions, and system health. Configuring alerts and dashboards to proactively identify and resolve issues. Implementing best practices for application observability in a cloud environment.\nThe following subsections will guide you through testing procedures and monitoring setup to ensure your FastFood Order System operates reliably and efficiently.\nContent: 8.1 Testing Application 8.2 Monitoring "
},
{
	"uri": "//localhost:1313/9-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "We will take the following steps to delete the resources we created in this workshop.\nDelete CloudWatch Log Groups Go to CloudWatch service management console Click Logs in the left sidebar.\nClick Log groups.\nSelect the log groups we created for this lab:\n/aws/lambda/OrderCommandHandler /aws/lambda/OrderEventProcessor /aws/lambda/OrderQueryHandler /aws/lambda/StateReconstructionHandler Click Actions.\nClick Delete log group(s).\nIn the confirmation dialog, click Delete to confirm deletion.\nDelete API Gateway Go to API Gateway service management console\nClick APIs in the left sidebar. Select the API FastFoodOrderAPI. Click Actions. Click Delete. Type confirm in the confirmation field. Click Delete to permanently delete the API. Delete CloudFront Distribution Go to CloudFront service management console\nClick Distributions in the left sidebar. Select the distribution we created (ID: E2GXEUIB6RGU9). Click Disable. Wait for the distribution status to change to Disabled. Select the disabled distribution. Click Delete. Click Delete to confirm deletion. Delete S3 Bucket and Objects Go to S3 service management console\nClick on the S3 bucket event-sourcing-fastfood-frontend. Click Empty. Type permanently delete in the confirmation field. Click Empty to delete all objects in the bucket. Click Exit. 2. After emptying the bucket:\nSelect the bucket event-sourcing-fastfood-frontend. Click Delete. Type the bucket name event-sourcing-fastfood-frontend in the confirmation field. Click Delete bucket to permanently delete the bucket. Delete DynamoDB Tables Go to DynamoDB service management console\nClick Tables in the left sidebar.\nSelect all tables we created:\nCustomerReadModel EventStore MenuItems OrderReadModel Click Actions.\nClick Delete.\nIn the confirmation dialog, type confirm in the text field.\nClick Delete to permanently delete the tables. Delete SNS Topic Go to SNS service management console\nClick Topics in the left sidebar. Select the topic OrderNotifications. Click Delete. In the confirmation dialog, type delete me in the text field. Click Delete to confirm deletion. Delete EventBridge Resources Go to EventBridge service management console\nClick Event buses in the left sidebar. Select the custom event bus FastFoodOrderBus. Click Delete. In the confirmation dialog, type delete in the text field. Click Delete to confirm deletion. 2. Still in EventBridge console:\nClick Rules in the left sidebar.\nSelect the rules we created:\nOrderEventProcessingRule StateReconstructionRule Click Delete.\nType delete in the confirmation field.\nClick Delete to confirm deletion. Delete Lambda Functions Go to Lambda service management console\nClick Functions in the left sidebar.\nSelect all functions we created:\nOrderCommandHandler OrderEventProcessor StateReconstructionHandler OrderQueryHandler Click Actions.\nClick Delete.\nIn the confirmation dialog, type confirm in the text field.\nClick Delete to permanently delete the functions. Delete IAM Role Go to IAM service management console\nClick Roles in the left sidebar. Search for EventSourcingLambdaRole. Click to select the role. Click Delete. Enter the role name EventSourcingLambdaRole in the text field. Click Delete to confirm deletion. "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]